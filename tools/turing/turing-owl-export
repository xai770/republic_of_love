#!/usr/bin/env python3
"""
turing-owl-export - Export OWL hierarchy to folder tree

Generates a navigable folder structure representing the OWL knowledge graph.
Both humans and AI can easily browse and review the structure.

Usage:
  turing-owl-export                    # Export to ./owl_export/
  turing-owl-export --output /tmp/owl  # Export to specific path
  turing-owl-export --stats            # Just show stats, don't export

Output structure:
  owl_export/
  ‚îú‚îÄ‚îÄ _INDEX.md              # Summary and stats
  ‚îú‚îÄ‚îÄ _ROOTS.md              # All taxonomy roots listed
  ‚îú‚îÄ‚îÄ entities/
  ‚îÇ   ‚îî‚îÄ‚îÄ {root}/
  ‚îÇ       ‚îî‚îÄ‚îÄ {folder}/
  ‚îÇ           ‚îî‚îÄ‚îÄ {skill}.md
  ‚îî‚îÄ‚îÄ _ORPHANS/              # Entities with no parent
      ‚îî‚îÄ‚îÄ {skill}.md

Author: Sandy
Date: January 2026
"""

import argparse
import os
import re
import shutil
import sys
from datetime import datetime
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))
from core.database import get_connection


def sanitize_filename(name: str) -> str:
    """Convert entity name to safe filename."""
    if not name:
        return "_unnamed"
    safe = re.sub(r'[<>:"/\\|?*\x00-\x1f]', '_', str(name))
    safe = re.sub(r'\s+', '_', safe)
    safe = safe.lower().strip('_')
    # Avoid overly long names
    if len(safe) > 80:
        safe = safe[:80]
    return safe or "_unnamed"


def get_entity_path(cursor, owl_id: int, max_depth: int = 15) -> list:
    """Get ancestry path from root to entity."""
    path = []
    current_id = owl_id
    
    for _ in range(max_depth):
        if current_id is None:
            break
        
        cursor.execute("""
            SELECT o.owl_id, o.canonical_name, o.owl_type,
                   r.related_owl_id as parent_id
            FROM owl o
            LEFT JOIN owl_relationships r ON o.owl_id = r.owl_id AND r.relationship = 'is_a'
            WHERE o.owl_id = %s
        """, (current_id,))
        
        row = cursor.fetchone()
        if not row:
            break
        
        path.insert(0, {
            'owl_id': row['owl_id'],
            'canonical_name': row['canonical_name'],
            'owl_type': row['owl_type']
        })
        current_id = row['parent_id']
    
    return path


def get_aliases(cursor, owl_id: int) -> list:
    """Get all names/aliases for an entity."""
    cursor.execute("""
        SELECT display_name, name_type, is_primary, observation_count
        FROM owl_names
        WHERE owl_id = %s
        ORDER BY is_primary DESC, name_type, display_name
    """, (owl_id,))
    return cursor.fetchall()


def get_relationships(cursor, owl_id: int) -> dict:
    """Get all relationships for an entity."""
    # Outgoing relationships (this entity ‚Üí other)
    cursor.execute("""
        SELECT r.relationship, o.owl_id, o.canonical_name
        FROM owl_relationships r
        JOIN owl o ON r.related_owl_id = o.owl_id
        WHERE r.owl_id = %s
        ORDER BY r.relationship, o.canonical_name
    """, (owl_id,))
    outgoing = cursor.fetchall()
    
    # Incoming relationships (other ‚Üí this entity)
    cursor.execute("""
        SELECT r.relationship, o.owl_id, o.canonical_name
        FROM owl_relationships r
        JOIN owl o ON r.owl_id = o.owl_id
        WHERE r.related_owl_id = %s
        ORDER BY r.relationship, o.canonical_name
    """, (owl_id,))
    incoming = cursor.fetchall()
    
    return {'outgoing': outgoing, 'incoming': incoming}


def generate_entity_md(cursor, entity: dict) -> str:
    """Generate markdown content for an entity."""
    lines = [f"# {entity['canonical_name']}"]
    lines.append("")
    lines.append(f"- **owl_id**: {entity['owl_id']}")
    lines.append(f"- **type**: {entity['owl_type']}")
    lines.append(f"- **status**: {entity['status']}")
    
    if entity.get('description'):
        lines.append(f"- **description**: {entity['description']}")
    
    # Aliases
    aliases = get_aliases(cursor, entity['owl_id'])
    if aliases:
        lines.append("")
        lines.append(f"## Aliases ({len(aliases)})")
        lines.append("")
        for a in aliases[:50]:  # Limit to 50
            primary = " ‚≠ê" if a['is_primary'] else ""
            count = f" ({a['observation_count']}x)" if a['observation_count'] else ""
            lines.append(f"- {a['display_name']} [{a['name_type']}]{primary}{count}")
        if len(aliases) > 50:
            lines.append(f"- ... and {len(aliases) - 50} more")
    
    # Relationships
    rels = get_relationships(cursor, entity['owl_id'])
    
    if rels['outgoing']:
        lines.append("")
        lines.append("## Relationships (outgoing)")
        lines.append("")
        current_type = None
        for r in rels['outgoing']:
            if r['relationship'] != current_type:
                current_type = r['relationship']
                lines.append(f"### {current_type}")
            lines.append(f"- [{r['canonical_name']}](../../{sanitize_filename(r['canonical_name'])}.md) (owl_id={r['owl_id']})")
    
    if rels['incoming'] and len(rels['incoming']) <= 20:  # Skip if too many children
        lines.append("")
        lines.append("## Relationships (incoming)")
        lines.append("")
        current_type = None
        for r in rels['incoming']:
            if r['relationship'] != current_type:
                current_type = r['relationship']
                lines.append(f"### {current_type} (children)")
            lines.append(f"- [{r['canonical_name']}]({sanitize_filename(r['canonical_name'])}.md) (owl_id={r['owl_id']})")
    elif rels['incoming']:
        lines.append("")
        lines.append(f"## Children ({len(rels['incoming'])} entities)")
        lines.append("")
        lines.append("_Too many to list - see subfolders_")
    
    lines.append("")
    lines.append("---")
    lines.append(f"_Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}_")
    
    return "\n".join(lines)


def generate_folder_index(cursor, folder: dict, children: list) -> str:
    """Generate _folder.md index for a directory."""
    lines = [f"# üìÅ {folder['canonical_name']}"]
    lines.append("")
    lines.append(f"- **owl_id**: {folder['owl_id']}")
    lines.append(f"- **type**: {folder['owl_type']}")
    
    if folder.get('description'):
        lines.append(f"- **description**: {folder['description']}")
    
    # Count by type
    folders = [c for c in children if c['owl_type'] == 'folder']
    skills = [c for c in children if c['owl_type'] == 'skill']
    other = [c for c in children if c['owl_type'] not in ('folder', 'skill')]
    
    lines.append("")
    lines.append("## Contents")
    lines.append("")
    lines.append(f"- **Subfolders**: {len(folders)}")
    lines.append(f"- **Skills**: {len(skills)}")
    if other:
        lines.append(f"- **Other**: {len(other)}")
    
    if folders:
        lines.append("")
        lines.append("### Subfolders")
        lines.append("")
        for f in sorted(folders, key=lambda x: x['canonical_name']):
            lines.append(f"- üìÅ [{f['canonical_name']}]({sanitize_filename(f['canonical_name'])}/_folder.md)")
    
    if skills and len(skills) <= 100:
        lines.append("")
        lines.append("### Skills")
        lines.append("")
        for s in sorted(skills, key=lambda x: x['canonical_name']):
            lines.append(f"- [{s['canonical_name']}]({sanitize_filename(s['canonical_name'])}.md)")
    elif skills:
        lines.append("")
        lines.append(f"### Skills ({len(skills)} total)")
        lines.append("")
        lines.append("_Too many to list - see .md files in this folder_")
    
    return "\n".join(lines)


def export_tree(output_dir: str, verbose: bool = True) -> dict:
    """Export entire OWL hierarchy to folder tree."""
    stats = {
        'roots': 0,
        'folders': 0,
        'skills': 0,
        'orphans': 0,
        'files_created': 0,
        'errors': []
    }
    
    # Clean output directory
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir)
    
    entities_dir = os.path.join(output_dir, 'entities')
    orphans_dir = os.path.join(output_dir, '_ORPHANS')
    os.makedirs(entities_dir)
    os.makedirs(orphans_dir)
    
    with get_connection() as conn:
        cursor = conn.cursor()
        
        # Get all active entities
        cursor.execute("""
            SELECT owl_id, canonical_name, owl_type, status, description
            FROM owl
            WHERE status = 'active'
            ORDER BY canonical_name
        """)
        all_entities = {row['owl_id']: dict(row) for row in cursor.fetchall()}
        
        if verbose:
            print(f"üìä Found {len(all_entities)} active entities")
        
        # Get all relationships
        cursor.execute("""
            SELECT owl_id, related_owl_id, relationship
            FROM owl_relationships
            WHERE relationship = 'is_a'
        """)
        parent_map = {row['owl_id']: row['related_owl_id'] for row in cursor.fetchall()}
        
        # Build child map
        child_map = {}
        for child_id, parent_id in parent_map.items():
            if parent_id not in child_map:
                child_map[parent_id] = []
            if child_id in all_entities:
                child_map[parent_id].append(all_entities[child_id])
        
        # Find roots (no parent)
        roots = [e for eid, e in all_entities.items() 
                 if eid not in parent_map and e['owl_type'] in ('taxonomy_root', 'folder')]
        stats['roots'] = len(roots)
        
        if verbose:
            print(f"üå≥ Found {len(roots)} root entities")
        
        # Generate _ROOTS.md
        roots_content = ["# OWL Taxonomy Roots", ""]
        roots_content.append(f"Total: {len(roots)} roots")
        roots_content.append("")
        for r in sorted(roots, key=lambda x: x['canonical_name']):
            child_count = len(child_map.get(r['owl_id'], []))
            roots_content.append(f"- [{r['canonical_name']}](entities/{sanitize_filename(r['canonical_name'])}/_folder.md) ({r['owl_type']}, {child_count} children)")
        
        with open(os.path.join(output_dir, '_ROOTS.md'), 'w') as f:
            f.write("\n".join(roots_content))
        stats['files_created'] += 1
        
        # Process each root and its descendants
        def process_entity(entity, parent_path):
            owl_id = entity['owl_id']
            name = sanitize_filename(entity['canonical_name'])
            
            if entity['owl_type'] in ('folder', 'taxonomy_root'):
                # Create folder
                folder_path = os.path.join(parent_path, name)
                os.makedirs(folder_path, exist_ok=True)
                stats['folders'] += 1
                
                # Get children
                children = child_map.get(owl_id, [])
                
                # Generate folder index
                index_content = generate_folder_index(cursor, entity, children)
                with open(os.path.join(folder_path, '_folder.md'), 'w') as f:
                    f.write(index_content)
                stats['files_created'] += 1
                
                # Process children recursively
                for child in children:
                    process_entity(child, folder_path)
            else:
                # Create entity file
                stats['skills'] += 1
                content = generate_entity_md(cursor, entity)
                filepath = os.path.join(parent_path, f"{name}.md")
                with open(filepath, 'w') as f:
                    f.write(content)
                stats['files_created'] += 1
        
        # Process roots
        for root in roots:
            if verbose:
                print(f"  üìÅ Processing {root['canonical_name']}...")
            process_entity(root, entities_dir)
        
        # Find orphans (skills with no parent)
        orphans = [e for eid, e in all_entities.items() 
                   if eid not in parent_map and e['owl_type'] not in ('taxonomy_root', 'folder')]
        stats['orphans'] = len(orphans)
        
        if verbose:
            print(f"üëª Found {len(orphans)} orphan entities")
        
        for orphan in orphans:
            content = generate_entity_md(cursor, orphan)
            filepath = os.path.join(orphans_dir, f"{sanitize_filename(orphan['canonical_name'])}.md")
            with open(filepath, 'w') as f:
                f.write(content)
            stats['files_created'] += 1
        
        # Generate main INDEX
        index_lines = [
            "# OWL Knowledge Graph Export",
            "",
            f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "## Statistics",
            "",
            f"- **Total entities**: {len(all_entities)}",
            f"- **Taxonomy roots**: {stats['roots']}",
            f"- **Folders**: {stats['folders']}",
            f"- **Skills/Leaves**: {stats['skills']}",
            f"- **Orphans**: {stats['orphans']}",
            f"- **Files created**: {stats['files_created']}",
            "",
            "## Structure",
            "",
            "```",
            f"{output_dir}/",
            "‚îú‚îÄ‚îÄ _INDEX.md          # This file",
            "‚îú‚îÄ‚îÄ _ROOTS.md          # All taxonomy roots",
            "‚îú‚îÄ‚îÄ entities/          # Hierarchical entity tree",
            "‚îÇ   ‚îî‚îÄ‚îÄ {root}/",
            "‚îÇ       ‚îî‚îÄ‚îÄ {folder}/",
            "‚îÇ           ‚îî‚îÄ‚îÄ {entity}.md",
            "‚îî‚îÄ‚îÄ _ORPHANS/          # Entities with no parent",
            "    ‚îî‚îÄ‚îÄ {entity}.md",
            "```",
            "",
            "## Quick Links",
            "",
            "- [All Roots](_ROOTS.md)",
            "- [Orphans](_ORPHANS/)",
            "",
            "## Health Check",
            "",
        ]
        
        # Health indicators
        orphan_pct = (stats['orphans'] / len(all_entities) * 100) if all_entities else 0
        if orphan_pct > 20:
            index_lines.append(f"‚ö†Ô∏è **High orphan rate**: {orphan_pct:.1f}% of entities have no parent")
        elif orphan_pct > 5:
            index_lines.append(f"‚ö° **Moderate orphan rate**: {orphan_pct:.1f}%")
        else:
            index_lines.append(f"‚úÖ **Low orphan rate**: {orphan_pct:.1f}%")
        
        if stats['roots'] > 10:
            index_lines.append(f"‚ö†Ô∏è **Too many roots**: {stats['roots']} (target: 4-10)")
        else:
            index_lines.append(f"‚úÖ **Root count**: {stats['roots']}")
        
        with open(os.path.join(output_dir, '_INDEX.md'), 'w') as f:
            f.write("\n".join(index_lines))
        stats['files_created'] += 1
    
    return stats


def show_stats():
    """Show OWL statistics without exporting."""
    with get_connection() as conn:
        cursor = conn.cursor()
        
        print("\nüìä OWL Statistics\n")
        
        # Total entities by type
        cursor.execute("""
            SELECT owl_type, COUNT(*) as cnt
            FROM owl
            WHERE status = 'active'
            GROUP BY owl_type
            ORDER BY cnt DESC
        """)
        print("Entities by type:")
        for row in cursor.fetchall():
            print(f"  {row['owl_type']}: {row['cnt']}")
        
        # Orphan count
        cursor.execute("""
            SELECT COUNT(*) as cnt
            FROM owl o
            WHERE o.status = 'active'
              AND NOT EXISTS (
                  SELECT 1 FROM owl_relationships r 
                  WHERE r.owl_id = o.owl_id AND r.relationship = 'is_a'
              )
        """)
        print(f"\nOrphans (no parent): {cursor.fetchone()['cnt']}")
        
        # Name counts
        cursor.execute("""
            SELECT name_type, COUNT(*) as cnt
            FROM owl_names
            GROUP BY name_type
            ORDER BY cnt DESC
        """)
        print("\nNames by type:")
        for row in cursor.fetchall():
            print(f"  {row['name_type']}: {row['cnt']}")


def main():
    parser = argparse.ArgumentParser(
        description="Export OWL hierarchy to navigable folder tree"
    )
    parser.add_argument(
        '--output', '-o',
        default='./owl_export',
        help='Output directory (default: ./owl_export)'
    )
    parser.add_argument(
        '--stats', '-s',
        action='store_true',
        help='Show statistics only, do not export'
    )
    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress progress output'
    )
    
    args = parser.parse_args()
    
    if args.stats:
        show_stats()
        return
    
    print(f"\nü¶â OWL Export ‚Üí {args.output}\n")
    
    stats = export_tree(args.output, verbose=not args.quiet)
    
    print(f"\n‚úÖ Export complete!")
    print(f"   üìÅ {stats['folders']} folders")
    print(f"   üìÑ {stats['skills']} entities")
    print(f"   üëª {stats['orphans']} orphans")
    print(f"   üìù {stats['files_created']} files created")
    print(f"\n   Open: {args.output}/_INDEX.md\n")


if __name__ == '__main__':
    main()
