#!/usr/bin/env python3
"""
turing-hash-scripts - Update script_code_hash for drift detection

Computes SHA1 hash of each thick actor script and stores in task_types.
Used to detect when scripts change without explicit acknowledgment.

Usage:
    ./tools/turing/turing-hash-scripts          # Show current status
    ./tools/turing/turing-hash-scripts --update  # Update hashes in DB
    ./tools/turing/turing-hash-scripts --check   # Check for drift (CI use)

Author: Arden
Date: 2026-01-15
"""

import argparse
import sys
from hashlib import sha1
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from core.database import get_connection


def compute_hash(file_path: Path) -> str:
    """Compute SHA1 hash of file."""
    if not file_path.exists():
        return None
    return sha1(file_path.read_bytes()).hexdigest()


def get_task_types_with_scripts(conn):
    """Fetch enabled actors that have scripts."""
    import psycopg2.extras
    cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
    cursor.execute("""
        SELECT actor_id as task_type_id, actor_name as task_type_name, 
               script_file_path as script_path, script_code_hash
        FROM actors
        WHERE enabled = true AND script_file_path IS NOT NULL
        ORDER BY actor_id
    """)
    return cursor.fetchall()


def show_status(conn):
    """Show current hash status for all scripts."""
    task_types = get_task_types_with_scripts(conn)
    
    print(f"{'ID':<6} {'Task Type':<42} {'Status':<12} {'Hash (stored â†’ file)'}")
    print("=" * 100)
    
    drift_count = 0
    missing_count = 0
    ok_count = 0
    
    for row in task_types:
        task_type_id = row['task_type_id']
        task_type_name = row['task_type_name']
        script_path = row['script_path']
        stored_hash = row['script_code_hash']
        
        full_path = PROJECT_ROOT / script_path
        file_hash = compute_hash(full_path)
        
        if not full_path.exists():
            status = "âŒ MISSING"
            hash_info = f"file not found: {script_path}"
            missing_count += 1
        elif stored_hash is None:
            status = "âš ï¸ NO HASH"
            hash_info = f"(none) â†’ {file_hash[:12]}..."
            drift_count += 1
        elif stored_hash != file_hash:
            status = "ðŸ”„ DRIFT"
            hash_info = f"{stored_hash[:12]}... â†’ {file_hash[:12]}..."
            drift_count += 1
        else:
            status = "âœ… OK"
            hash_info = f"{stored_hash[:12]}..."
            ok_count += 1
        
        print(f"{task_type_id:<6} {task_type_name:<42} {status:<12} {hash_info}")
    
    print()
    print(f"Summary: {ok_count} OK, {drift_count} drift/missing hash, {missing_count} missing files")
    
    return drift_count + missing_count


def update_hashes(conn):
    """Update all script hashes in database."""
    task_types = get_task_types_with_scripts(conn)
    cursor = conn.cursor()
    
    updated = 0
    errors = 0
    
    for row in task_types:
        task_type_id = row['task_type_id']
        task_type_name = row['task_type_name']
        script_path = row['script_path']
        stored_hash = row['script_code_hash']
        
        full_path = PROJECT_ROOT / script_path
        
        if not full_path.exists():
            print(f"âŒ {task_type_name}: file not found ({script_path})")
            errors += 1
            continue
        
        file_hash = compute_hash(full_path)
        
        if stored_hash == file_hash:
            print(f"âœ… {task_type_name}: hash unchanged")
            continue
        
        cursor.execute("""
            UPDATE actors 
            SET script_code_hash = %s
            WHERE actor_id = %s
        """, (file_hash, task_type_id))
        
        if stored_hash:
            print(f"ðŸ”„ {task_type_name}: {stored_hash[:12]}... â†’ {file_hash[:12]}...")
        else:
            print(f"ðŸ“ {task_type_name}: set hash {file_hash[:12]}...")
        updated += 1
    
    conn.commit()
    print()
    print(f"Updated {updated} hashes, {errors} errors")
    
    return errors


def check_drift(conn):
    """Check for drift (for CI). Exit 1 if drift detected."""
    task_types = get_task_types_with_scripts(conn)
    
    drift_found = False
    
    for row in task_types:
        task_type_id = row['task_type_id']
        task_type_name = row['task_type_name']
        script_path = row['script_path']
        stored_hash = row['script_code_hash']
        
        full_path = PROJECT_ROOT / script_path
        
        if not full_path.exists():
            print(f"ERROR: {task_type_name} - file missing: {script_path}")
            drift_found = True
            continue
        
        file_hash = compute_hash(full_path)
        
        if stored_hash is None:
            print(f"WARNING: {task_type_name} - no stored hash")
            drift_found = True
        elif stored_hash != file_hash:
            print(f"DRIFT: {task_type_name} - hash mismatch")
            print(f"  stored: {stored_hash}")
            print(f"  file:   {file_hash}")
            drift_found = True
    
    if drift_found:
        print()
        print("Drift detected! Run: ./tools/turing/turing-hash-scripts --update")
        return 1
    else:
        print("No drift detected.")
        return 0


def main():
    parser = argparse.ArgumentParser(description="Manage script hashes for drift detection")
    parser.add_argument('--update', action='store_true', help='Update hashes in database')
    parser.add_argument('--check', action='store_true', help='Check for drift (exit 1 if found)')
    args = parser.parse_args()
    
    with get_connection() as conn:
        if args.update:
            errors = update_hashes(conn)
            sys.exit(1 if errors > 0 else 0)
        elif args.check:
            result = check_drift(conn)
            sys.exit(result)
        else:
            issues = show_status(conn)
            if issues > 0:
                print("\nRun with --update to fix hashes")


if __name__ == '__main__':
    main()
