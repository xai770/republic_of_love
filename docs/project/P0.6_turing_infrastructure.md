---
id: P0.6
title: "Infrastructure - Turing Engine"
phase: 0
status: completed
owner: xai
priority: critical
completed_date: 2026-01
effort: 100h+
---

# P0.6 Infrastructure - Turing Engine

## Goal

Build an orchestration engine that chains humans, AI models, and scripts to process data.

## Status: ✅ COMPLETED (Evolved over 1 year)

## Architecture Evolution

### Era 1: Push Architecture (2025)

```
workflows → queue → batcher → actors
```
- Explicit workflow definitions
- Queue tables for pending work
- Batcher grouped by model

**Problem:** Complex, many tables, hard to debug.

### Era 2: Pull Architecture (Jan 2026)

```
actors.work_query → pull_daemon → execute → tickets
```
- Actors find their own work
- No queue tables
- work_query is SQL that returns pending items

**Result:** Simpler, fewer tables, easier to understand.

## Current Schema (19 tables)

| Category | Tables |
|----------|--------|
| Core | `actors`, `tickets`, `batches` |
| Content | `postings`, `posting_facets`, `profiles`, `profile_facets`, `profile_work_history` |
| Matching | `profile_posting_matches`, `embeddings` |
| Taxonomy | `owl`, `owl_names`, `owl_relationships`, `owl_pending` |
| Reference | `city_country_map`, `onet_technology_skills` |
| Archive | `_archive_*`, `attribute_history` |

### Key Tables

**actors** — WHO/WHAT does work
```sql
actors (
    actor_id, actor_name, actor_type,
    script_file_path,       -- Python script
    work_query,             -- SQL to find pending work
    pull_enabled,           -- Daemon picks up work?
    batch_size,             -- Items per run
    timeout_seconds,
    ...
)
```

**tickets** — Execution log (what DID happen)
```sql
tickets (
    ticket_id, actor_id, status,
    input, output,          -- JSONB
    chain_id, chain_depth,  -- Loop protection
    subject_type, subject_id,
    created_at, completed_at,
    error_message
)
```

## Pull Daemon

`scripts/pull_daemon.py` — The heartbeat of Turing.

```python
while True:
    for actor in get_pull_enabled_actors():
        work = execute(actor.work_query)
        for item in work[:actor.batch_size]:
            ticket = create_ticket(actor, item)
            result = run_actor(actor.script_file_path, ticket)
            complete_ticket(ticket, result)
    sleep(poll_interval)
```

## Loop Protection

Task chains can spawn infinitely. Protection:

```sql
tickets.chain_id    -- 32-char UUID, inherited from parent
tickets.chain_depth -- Increments per spawn

-- Spawn fails if:
--   1. chain_depth > 20
--   2. Same (chain_id, actor_id, subject_id) already exists
```

## RAQ Methodology

**RAQ = Repeatable, Auditable, Quality controlled**

```
DEVELOP → STABILIZE → PROVE → QA GATE → PRODUCTION
```

Tools in `tools/turing/`:
- `turing-harness` — Direct actor testing
- `turing-raq` — Repeatability testing (3×N runs)
- `turing-qa` — QA sampling
- `turing-matrix` — Cross-model comparison
- `turing-chat` — Interactive prompt iteration
- `turing-dashboard` — Live TUI + watchdog

## Model-First Batching

**Directive #7:** Load model once, exhaust all work before switching.

```
❌ Actor A (qwen2.5) → Actor B (mistral) → Actor A (qwen2.5) → ...
✅ All Actor A work → switch → All Actor B work → ...
```

GPU utilization: 30-50% (thrashing) vs 95-100% (batched).

## Lessons Learned

1. **Pull > Push** — Actors finding work beats queue management.
2. **Data is queue** — If `extracted_summary IS NULL`, that IS the queue.
3. **Schema is documentation** — Column comments are the spec.
4. **Fail loud** — Errors surface bugs; silence hides them.
5. **Thick actors** — One script does fetch→LLM→save. Readable, testable.
