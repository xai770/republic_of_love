#!/usr/bin/env python3
"""
Route Inventory Generator - Auto-generates docs/ROUTES.md

Usage:
    python scripts/generate_route_inventory.py              # Generate ROUTES.md
    python scripts/generate_route_inventory.py --check      # Check if up-to-date (for CI)

Run automatically via pre-commit hook when router files change.
"""

import argparse
import re
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Dict

PROJECT_ROOT = Path(__file__).parent.parent

def extract_routes_from_file(filepath: Path) -> List[Dict]:
    """Extract route definitions from a Python file."""
    routes = []
    content = filepath.read_text()
    lines = content.split('\n')
    
    # Find router prefix
    prefix_match = re.search(r'APIRouter\(prefix=["\']([^"\']+)["\']', content)
    prefix = prefix_match.group(1) if prefix_match else ''
    
    current_docstring = None
    
    for i, line in enumerate(lines):
        # Capture docstrings for route descriptions
        if '"""' in line or "'''" in line:
            # Simple single-line docstring
            doc_match = re.search(r'["\'\s]{3}(.+?)["\'\s]{3}', line)
            if doc_match:
                current_docstring = doc_match.group(1).strip()
        
        # Match route decorators
        route_match = re.match(r'\s*@router\.(get|post|put|delete|patch)\(["\']([^"\']+)["\']', line)
        if route_match:
            method = route_match.group(1).upper()
            path = route_match.group(2)
            full_path = prefix + path if not path.startswith(prefix) else path
            
            # Look for response_class to determine if it's HTML
            is_html = 'HTMLResponse' in line or 'response_class=HTMLResponse' in lines[i] if i < len(lines) else False
            
            # Get function name from next non-decorator line
            func_name = None
            for j in range(i+1, min(i+5, len(lines))):
                func_match = re.match(r'\s*(?:async\s+)?def\s+(\w+)', lines[j])
                if func_match:
                    func_name = func_match.group(1)
                    # Get docstring if exists
                    if j+1 < len(lines) and ('"""' in lines[j+1] or "'''" in lines[j+1]):
                        doc_line = lines[j+1]
                        doc_match = re.search(r'["\'\s]{3}(.+)', doc_line)
                        if doc_match:
                            current_docstring = doc_match.group(1).replace('"""', '').replace("'''", '').strip()
                    break
            
            routes.append({
                'method': method,
                'path': full_path,
                'func': func_name,
                'description': current_docstring,
                'is_html': is_html,
                'file': filepath.name,
            })
            current_docstring = None
    
    return routes


def extract_templates() -> List[Dict]:
    """List all HTML templates."""
    templates_dir = PROJECT_ROOT / 'frontend' / 'templates'
    templates = []
    
    if templates_dir.exists():
        for f in sorted(templates_dir.glob('*.html')):
            if f.name == 'base.html':
                continue
            templates.append({
                'name': f.name,
                'size': f.stat().st_size,
                'modified': datetime.fromtimestamp(f.stat().st_mtime).strftime('%Y-%m-%d'),
            })
    
    return templates


def generate_markdown(routes: List[Dict], templates: List[Dict]) -> str:
    """Generate the ROUTES.md content."""
    now = datetime.now().strftime('%Y-%m-%d %H:%M')
    
    md = f"""# Route Inventory
> Auto-generated by `scripts/generate_route_inventory.py`  
> Last updated: {now}

## Quick Links (Production)

| Page | URL | Description |
|------|-----|-------------|
| Home/Lobby | [/](https://talent.yoga/) | Landing page |
| Dashboard | [/dashboard](https://talent.yoga/dashboard) | User's job matches |
| Profile | [/profile](https://talent.yoga/profile) | Edit skills & preferences |
| Matches | [/matches](https://talent.yoga/matches) | Browse match details |
| Messages | [/messages](https://talent.yoga/messages) | Y2Y chat |
| Market | [/market](https://talent.yoga/market) | Job market browser |
| Admin Console | [/admin/console](https://talent.yoga/admin/console) | System stats |

---

## All Routes

### üåê HTML Pages (User-Facing)

| Method | Path | Function | Description |
|--------|------|----------|-------------|
"""
    
    # HTML routes first
    html_routes = [r for r in routes if r['is_html'] or 'HTMLResponse' in str(r)]
    for r in sorted(html_routes, key=lambda x: x['path']):
        desc = r['description'] or ''
        md += f"| {r['method']} | `{r['path']}` | {r['func']} | {desc[:50]} |\n"
    
    md += """
### üîå API Endpoints

| Method | Path | Function | File |
|--------|------|----------|------|
"""
    
    # API routes
    api_routes = [r for r in routes if not r['is_html'] and 'HTMLResponse' not in str(r)]
    for r in sorted(api_routes, key=lambda x: (x['path'], x['method'])):
        md += f"| {r['method']} | `{r['path']}` | {r['func']} | {r['file']} |\n"
    
    md += f"""
---

## Templates

| Template | Size | Last Modified |
|----------|------|---------------|
"""
    
    for t in templates:
        size_kb = t['size'] / 1024
        md += f"| {t['name']} | {size_kb:.1f} KB | {t['modified']} |\n"
    
    md += f"""
---

## Route Statistics

- **Total Routes**: {len(routes)}
- **HTML Pages**: {len(html_routes)}
- **API Endpoints**: {len(api_routes)}
- **Templates**: {len(templates)}

## How to Update

This file is auto-generated. To update:

```bash
python scripts/generate_route_inventory.py
```

Or it updates automatically on commit when router files change.
"""
    
    return md


def main():
    parser = argparse.ArgumentParser(description='Generate route inventory')
    parser.add_argument('--check', action='store_true', help='Check if ROUTES.md is up-to-date')
    args = parser.parse_args()
    
    # Find all router files
    routers_dir = PROJECT_ROOT / 'api' / 'routers'
    all_routes = []
    
    for router_file in routers_dir.glob('*.py'):
        if router_file.name.startswith('__'):
            continue
        routes = extract_routes_from_file(router_file)
        all_routes.extend(routes)
    
    # Also check main.py for direct routes
    main_py = PROJECT_ROOT / 'api' / 'main.py'
    if main_py.exists():
        # Extract page routes from main.py
        content = main_py.read_text()
        for match in re.finditer(r'@app\.(get|post)\(["\']([^"\']+)["\'].*?response_class=HTMLResponse', content, re.DOTALL):
            all_routes.append({
                'method': match.group(1).upper(),
                'path': match.group(2),
                'func': 'main',
                'description': '',
                'is_html': True,
                'file': 'main.py',
            })
    
    templates = extract_templates()
    markdown = generate_markdown(all_routes, templates)
    
    output_path = PROJECT_ROOT / 'docs' / 'ROUTES.md'
    
    if args.check:
        if output_path.exists():
            current = output_path.read_text()
            # Compare ignoring timestamp line
            current_lines = [l for l in current.split('\n') if not l.startswith('> Last updated:')]
            new_lines = [l for l in markdown.split('\n') if not l.startswith('> Last updated:')]
            if current_lines != new_lines:
                print("‚ùå ROUTES.md is out of date. Run: python scripts/generate_route_inventory.py")
                return 1
        else:
            print("‚ùå ROUTES.md doesn't exist. Run: python scripts/generate_route_inventory.py")
            return 1
        print("‚úÖ ROUTES.md is up-to-date")
        return 0
    
    output_path.parent.mkdir(exist_ok=True)
    output_path.write_text(markdown)
    print(f"‚úÖ Generated {output_path}")
    print(f"   Routes: {len(all_routes)}, Templates: {len(templates)}")
    return 0


if __name__ == '__main__':
    sys.exit(main())
