{% extends "base.html" %}

{% block title %}Job Market Terrain ‚Äî talent.yoga{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="/static/css/pages/market.css?v=20260216b">
{% endblock %}

{% block content %}

<div class="market-container">
    <a href="/dashboard" class="back-link">‚Üê Back to Dashboard</a>
    
    <div class="market-header">
        <h1>üåç German Job Market Terrain</h1>
        <p class="subtitle">UMAP visualization of <span id="subtitle-count">42,000+</span> job postings based on semantic similarity</p>
    </div>
    
    <div class="market-stats">
        <div class="stat-box">
            <div class="number" id="total-postings">‚Äî</div>
            <div class="label">Job Postings</div>
        </div>
        <div class="stat-box">
            <div class="number" id="total-sources">‚Äî</div>
            <div class="label">Data Sources</div>
        </div>
        <div class="stat-box">
            <div class="number" id="total-cities">‚Äî</div>
            <div class="label">Cities</div>
        </div>
        <div class="stat-box">
            <div class="number" id="weeks-span">‚Äî</div>
            <div class="label">Weeks of Data</div>
        </div>
    </div>
    
    <div class="viz-tabs">
        <button class="viz-tab active" onclick="showPanel('terrain')">üó∫Ô∏è Terrain Map</button>
        <button class="viz-tab" onclick="showPanel('time')">üìÖ Time Evolution</button>
        <button class="viz-tab" onclick="showPanel('bi')">üìä BI Dashboard</button>
    </div>
    
    <div id="terrain-panel" class="viz-panel active">
        <div id="terrain-chart" class="loading">Loading terrain map...</div>
    </div>
    
    <div id="time-panel" class="viz-panel">
        <div id="time-chart" class="loading">Loading time animation...</div>
    </div>
    
    <div id="bi-panel" class="viz-panel">
        <div id="bi-chart" class="loading">Loading BI dashboard...</div>
    </div>
</div>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script>
    let dataLoaded = {terrain: false, time: false, bi: false};
    let marketData = null;
    
    function showPanel(name) {
        // Update tabs
        document.querySelectorAll('.viz-tab').forEach(tab => tab.classList.remove('active'));
        event.target.classList.add('active');
        
        // Show panel
        document.querySelectorAll('.viz-panel').forEach(panel => panel.classList.remove('active'));
        document.getElementById(name + '-panel').classList.add('active');
        
        // Load data if needed
        if (!dataLoaded[name]) {
            loadChart(name);
        }
    }
    
    async function loadMarketData() {
        if (marketData) return marketData;
        
        const response = await fetch('/viz/market/data');
        marketData = await response.json();
        
        // Update stats
        document.getElementById('total-postings').textContent = marketData.stats.total_postings.toLocaleString();
        document.getElementById('subtitle-count').textContent = marketData.stats.total_postings.toLocaleString();
        document.getElementById('total-sources').textContent = marketData.stats.total_sources;
        document.getElementById('total-cities').textContent = marketData.stats.total_cities;
        document.getElementById('weeks-span').textContent = marketData.stats.weeks_span;
        
        return marketData;
    }
    
    async function loadChart(chartType) {
        const container = document.getElementById(chartType + '-chart');
        
        try {
            const data = await loadMarketData();
            
            // Clear loading state
            container.classList.remove('loading');
            container.textContent = '';
            
            if (chartType === 'terrain') {
                renderTerrain(container, data);
            } else if (chartType === 'time') {
                renderTimeEvolution(container, data);
            } else if (chartType === 'bi') {
                renderBIDashboard(container, data);
            }
            
            dataLoaded[chartType] = true;
        } catch (err) {
            container.classList.remove('loading');
            container.innerHTML = `<div style="color:red; text-align:center; padding:50px;">
                Error loading data: ${err.message}
            </div>`;
        }
    }
    
    function renderTerrain(container, data) {
        const traces = [];
        
        // Extended color palette for domains + auto-clusters
        const domainColors = {
            // Official domains (warm/saturated)
            'it_software': '#2ecc71',      // Green
            'healthcare': '#e74c3c',       // Red
            'finance': '#3498db',          // Blue
            'construction_trades': '#f39c12', // Orange
            'logistics': '#9b59b6',        // Purple
            'hospitality': '#1abc9c',      // Teal
            'childcare': '#e91e63',        // Pink
            'retail': '#00bcd4',           // Cyan
            'legal': '#795548',            // Brown
            'education': '#ff9800',        // Amber
            'security': '#607d8b',         // Blue Grey
            'aviation': '#673ab7',         // Deep Purple
            
            // Auto-discovered clusters (distinct hues)
            'facharzt_oberarzt': '#c0392b',      // Dark red (doctors)
            'elektroniker_mechatroniker': '#d35400', // Burnt orange (technicians)
            'pflegefachkraft_erzieher': '#8e44ad',   // Purple (care/education)
            'engineer_analyst': '#16a085',       // Sea green (tech/English)
            'sachbearbeiter_mitarbeiter': '#2980b9', // Blue (office)
            'staplerfahrer_reinigungskraft': '#7f8c8d', // Grey (old - should be gone)
            'lager_stapler': '#e67e22',          // Orange (warehouse/forklift - skilled)
            'reinigung_facility': '#95a5a6',     // Light grey (cleaning - unskilled)
            'produktion_helfer': '#f39c12',      // Amber (production - semi-skilled)
            'gewerblich_sonstig': '#bdc3c7',     // Grey (other trades)
            'manager_mitarbeiter': '#27ae60',    // Green (management)
            'manager_senior': '#1abc9c',         // Teal (senior mgmt)
            'manager_chef': '#e67e22',           // Orange (hospitality mgmt)
            'koch_k√∂chin': '#d63031',            // Red (chefs)
            'student_einzelhandel': '#fdcb6e',   // Yellow (students retail)
            'student_basis': '#ffeaa7',          // Light yellow (students)
            'services_business': '#74b9ff',      // Light blue (services)
            'consultant_zerspanungsmechaniker': '#a29bfe', // Lavender
            'inhouse_teilzeit': '#55efc4',       // Mint
            'f√ºhrungskraft_filiale': '#fab1a0',  // Salmon
            'aushilfe_geringf√ºgiger': '#dfe6e9', // Light grey (part-time)
            'manager_gender': '#b2bec3',         // Grey
            'oberarzt_facharzt': '#ff7675',      // Coral (senior doctors)
            
            // Fallbacks
            'unknown': '#bdc3c7',
            'unclassified': '#ecf0f1',
            'misc': '#95a5a6'
        };
        
        // Generate colors for any missing domains
        const generateColor = (str) => {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 65%, 55%)`;
        };
        
        // Get unique domains sorted by count (descending)
        const domainCounts = {};
        data.domain.forEach(d => domainCounts[d] = (domainCounts[d] || 0) + 1);
        const domains = Object.keys(domainCounts).sort((a, b) => domainCounts[b] - domainCounts[a]);
        
        // Add points colored by domain
        domains.forEach(domain => {
            const mask = data.domain.map((d, i) => d === domain ? i : -1).filter(i => i >= 0);
            if (mask.length === 0) return;
            
            const displayName = domain.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const color = domainColors[domain] || generateColor(domain);
            traces.push({
                type: 'scattergl',
                mode: 'markers',
                x: mask.map(i => data.umap_x[i]),
                y: mask.map(i => data.umap_y[i]),
                text: mask.map(i => data.job_title[i]),
                customdata: mask.map(i => ({city: data.location_city[i], source: data.source[i]})),
                marker: {
                    size: domain === 'unknown' || domain === 'unclassified' ? 3 : 5,
                    color: domainColors[domain] || '#888',
                    opacity: domain === 'unknown' || domain === 'unclassified' ? 0.3 : 0.6
                },
                name: `${displayName} (${mask.length.toLocaleString()})`,
                hovertemplate: '<b>%{text}</b><br>%{customdata.city}<extra>' + displayName + '</extra>'
            });
        });
        
        // Add domain cluster labels (annotations at centroid of each domain)
        const annotations = [];
        domains.filter(d => d !== 'unknown' && d !== 'unclassified' && domainCounts[d] > 100).forEach(domain => {
            const mask = data.domain.map((d, i) => d === domain ? i : -1).filter(i => i >= 0);
            const cx = mask.reduce((sum, i) => sum + data.umap_x[i], 0) / mask.length;
            const cy = mask.reduce((sum, i) => sum + data.umap_y[i], 0) / mask.length;
            
            annotations.push({
                x: cx, y: cy,
                text: domain.replace(/_/g, ' ').toUpperCase(),
                showarrow: false,
                font: {size: 11, color: '#333', family: 'Arial Black'},
                bgcolor: 'rgba(255,255,255,0.7)',
                borderpad: 3
            });
        });
        
        Plotly.newPlot(container, traces, {
            title: 'üåç German Job Market Terrain by Domain<br><sup>Hover over dots to see job titles. Click legend to toggle domains.</sup>',
            showlegend: true,
            legend: {x: 1.02, y: 1, font: {size: 10}},
            xaxis: {title: 'UMAP 1', showgrid: false, zeroline: false},
            yaxis: {title: 'UMAP 2', showgrid: false, zeroline: false},
            plot_bgcolor: '#f8f9fa',
            hovermode: 'closest',
            annotations: annotations
        }, {responsive: true});
    }
    
    function renderTimeEvolution(container, data) {
        // Group by week
        const weeks = [...new Set(data.week)].sort();
        const frames = [];
        const sliderSteps = [];
        
        weeks.forEach(week => {
            const mask = data.week.map((w, i) => w <= week ? i : -1).filter(i => i >= 0);
            frames.push({
                name: week,
                data: [{
                    x: mask.map(i => data.umap_x[i]),
                    y: mask.map(i => data.umap_y[i]),
                    text: mask.map(i => data.job_title[i])
                }]
            });
            sliderSteps.push({
                method: 'animate',
                label: week,
                args: [[week], {mode: 'immediate', transition: {duration: 300}}]
            });
        });
        
        const initialMask = data.week.map((w, i) => w <= weeks[0] ? i : -1).filter(i => i >= 0);
        
        Plotly.newPlot(container, [{
            type: 'scattergl',
            mode: 'markers',
            x: initialMask.map(i => data.umap_x[i]),
            y: initialMask.map(i => data.umap_y[i]),
            text: initialMask.map(i => data.job_title[i]),
            marker: {size: 5, color: '#667eea', opacity: 0.6},
            hovertemplate: '<b>%{text}</b><extra></extra>'
        }], {
            title: 'üìÖ Job Market Evolution by Week<br><sup>Use slider to see when jobs appeared</sup>',
            xaxis: {showgrid: false, showticklabels: false, title: ''},
            yaxis: {showgrid: false, showticklabels: false, title: ''},
            plot_bgcolor: '#f0f4f8',
            sliders: [{
                pad: {t: 30},
                currentvalue: {prefix: 'Week: ', visible: true},
                steps: sliderSteps
            }],
            updatemenus: [{
                type: 'buttons',
                showactive: false,
                y: 0,
                x: 0.1,
                xanchor: 'right',
                buttons: [{
                    label: '‚ñ∂ Play',
                    method: 'animate',
                    args: [null, {fromcurrent: true, frame: {duration: 500}}]
                }, {
                    label: '‚è∏ Pause',
                    method: 'animate',
                    args: [[null], {mode: 'immediate'}]
                }]
            }]
        }, {responsive: true}).then(() => {
            Plotly.addFrames(container, frames);
        });
    }
    
    function renderBIDashboard(container, data) {
        // Prepare aggregated data
        const stateCounts = {};
        const sourceCounts = {};
        const cityCounts = {};
        const dateCounts = {};
        
        data.source.forEach((s, i) => {
            const state = data.location_state[i] || 'Unknown';
            const city = data.location_city[i] || 'Unknown';
            const date = data.date_seen[i];
            
            stateCounts[state] = (stateCounts[state] || 0) + 1;
            sourceCounts[s] = (sourceCounts[s] || 0) + 1;
            cityCounts[city] = (cityCounts[city] || 0) + 1;
            dateCounts[date] = (dateCounts[date] || 0) + 1;
        });
        
        const topStates = Object.entries(stateCounts).sort((a,b) => b[1]-a[1]).slice(0, 15);
        const topCities = Object.entries(cityCounts).sort((a,b) => b[1]-a[1]).slice(0, 15);
        const datesSorted = Object.entries(dateCounts).sort((a,b) => a[0].localeCompare(b[0]));
        
        Plotly.newPlot(container, [{
            type: 'bar',
            x: topStates.map(s => s[0]),
            y: topStates.map(s => s[1]),
            marker: {color: '#667eea'},
            name: 'By State',
            xaxis: 'x1',
            yaxis: 'y1'
        }, {
            type: 'pie',
            labels: Object.keys(sourceCounts),
            values: Object.values(sourceCounts),
            hole: 0.4,
            textinfo: 'label+percent',
            domain: {x: [0.55, 1], y: [0.55, 1]},
            name: 'By Source'
        }, {
            type: 'scatter',
            mode: 'lines+markers',
            x: datesSorted.map(d => d[0]),
            y: datesSorted.map(d => d[1]),
            line: {color: '#ff7f0e'},
            name: 'Over Time',
            xaxis: 'x2',
            yaxis: 'y2'
        }, {
            type: 'bar',
            orientation: 'h',
            x: topCities.map(c => c[1]),
            y: topCities.map(c => c[0]),
            marker: {color: 'steelblue'},
            name: 'Top Cities',
            xaxis: 'x3',
            yaxis: 'y3'
        }], {
            title: 'üìä Job Market BI Dashboard',
            grid: {rows: 2, columns: 2, pattern: 'independent'},
            xaxis1: {domain: [0, 0.45], anchor: 'y1', tickangle: 45},
            yaxis1: {domain: [0.55, 1], anchor: 'x1', title: 'Count'},
            xaxis2: {domain: [0, 0.45], anchor: 'y2'},
            yaxis2: {domain: [0, 0.4], anchor: 'x2', title: 'Count'},
            xaxis3: {domain: [0.55, 1], anchor: 'y3'},
            yaxis3: {domain: [0, 0.4], anchor: 'x3', autorange: 'reversed'},
            annotations: [
                {text: 'Postings by State', x: 0.22, y: 1.05, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 14}},
                {text: 'By Source', x: 0.78, y: 1.05, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 14}},
                {text: 'Postings Over Time', x: 0.22, y: 0.45, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 14}},
                {text: 'Top 15 Cities', x: 0.78, y: 0.45, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 14}}
            ],
            showlegend: false
        }, {responsive: true});
    }
    
    // Load terrain on page load
    document.addEventListener('DOMContentLoaded', () => loadChart('terrain'));
</script>
{% endblock %}
