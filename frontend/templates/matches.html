{% extends "base.html" %}

{% block title %}Match Dashboard ‚Äî talent.yoga{% endblock %}

{% block content %}
<div class="app-layout">
    {% include "partials/header.html" %}
    
    {% set active_page = 'matches' %}
    {% include "partials/sidebar.html" %}
    
    <main class="main-content match-dashboard">
    <header class="dashboard-header">
        <h1>{{ t("matches.page_title") }}</h1>
        <p class="subtitle">{{ t("matches.page_subtitle") }}</p>
    </header>
    
    <!-- Filters -->
    <div class="filters">
        <div class="filter-tabs">
            <button class="filter-tab active" data-filter="all">{{ t("matches.filter_all") }}</button>
            <button class="filter-tab" data-filter="APPLY">{{ t("matches.filter_recommended") }}</button>
            <button class="filter-tab" data-filter="SKIP">{{ t("matches.filter_skipped") }}</button>
            <button class="filter-tab" data-filter="favorites">{{ t("matches.filter_favorites") }}</button>
            <button class="filter-tab" data-filter="interested">{{ t("matches.filter_interested") }}</button>
            <button class="filter-tab" data-filter="unread">{{ t("matches.filter_unread") }}</button>
        </div>
        <div class="filter-controls">
            <select id="score-filter" onchange="applyFilters()">
                <option value="">{{ t("matches.score_any") }}</option>
                <option value="90">90%+</option>
                <option value="80">80%+</option>
                <option value="70">70%+</option>
            </select>
            <select id="sort-by" onchange="applyFilters()">
                <option value="recommendation">{{ t("matches.sort_recommended") }}</option>
                <option value="score">{{ t("matches.sort_score") }}</option>
                <option value="date">{{ t("matches.sort_newest") }}</option>
            </select>
        </div>
    </div>
    
    <!-- Match Cards -->
    <div class="match-grid" id="match-grid">
        <!-- Populated by JS -->
    </div>
    
    <!-- Empty State -->
    <div class="empty-state hidden" id="empty-state">
        <span class="empty-icon"><img src="/static/images/icons/target.png" alt="üéØ"></span>
        <h2>{{ t("matches.empty_title") }}</h2>
        <p>Complete your <a href="/profile">profile</a> to start seeing job matches.</p>
    </div>
    
    <!-- Loading -->
    <div class="loading-state" id="loading-state">
        <div class="spinner"></div>
        <p>{{ t("matches.loading") }}</p>
    </div>
    </main>
</div><!-- /.app-layout -->

<!-- Report Modal -->
<div class="modal-overlay hidden" id="report-modal">
    <div class="modal modal-large">
        <div class="modal-header">
            <h2 id="report-title">{{ t("matches.report_modal_title") }}</h2>
            <button class="modal-close" onclick="closeReportModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="report-content" id="report-content">
                <!-- Rendered markdown -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeReportModal()">{{ t("matches.close") }}</button>
            <a href="#" target="_blank" class="btn" id="view-job-btn">{{ t("matches.view_original_job") }}</a>
        </div>
    </div>
</div>
    <!-- Styles moved to /static/css/style.css -->
<script>
// ‚îÄ‚îÄ i18n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const I18N = {
    company_unknown:      '{{ t("matches.company_unknown") }}',
    match_score_suffix:   '{{ t("matches.match_score_suffix") }}',
    fav_remove:           '{{ t("matches.fav_remove") }}',
    fav_add:              '{{ t("matches.fav_add") }}',
    badge_apply:          '{{ t("matches.badge_apply") }}',
    badge_review:         '{{ t("matches.badge_review") }}',
    view_report:          '{{ t("matches.view_report") }}',
    btn_interested:       '{{ t("matches.btn_interested") }}',
    btn_interest:         '{{ t("matches.btn_interest") }}',
    research_pending:     '{{ t("matches.research_pending") }}',
    research_view_doug:   '{{ t("matches.research_view_doug") }}',
    research_view:        '{{ t("matches.research_view") }}',
    research_ask:         '{{ t("matches.research_ask") }}',
    feedback_agree:       '{{ t("matches.feedback_agree") }}',
    feedback_disagree:    '{{ t("matches.feedback_disagree") }}',
    status_applied:       '{{ t("matches.status_applied") }}',
    status_interviewing:  '{{ t("matches.status_interviewing") }}',
    status_offered:       '{{ t("matches.status_offered") }}',
    status_rejected:      '{{ t("matches.status_rejected") }}',
    status_withdrawn:     '{{ t("matches.status_withdrawn") }}',
    outcome_placeholder:  '{{ t("matches.outcome_placeholder") }}',
    outcome_hired:        '{{ t("matches.outcome_hired") }}',
    outcome_not_selected: '{{ t("matches.outcome_not_selected") }}',
    outcome_ghosted:      '{{ t("matches.outcome_ghosted") }}',
    outcome_withdrew:     '{{ t("matches.outcome_withdrew") }}',
    btn_applied:          '{{ t("matches.btn_applied") }}',
    rate_label:           '{{ t("matches.rate_label") }}',
    report_loading:       '{{ t("matches.report_loading") }}',
    no_results_filtered:  '{{ t("matches.no_results_filtered") }}',
    load_error:           '{{ t("matches.load_error") }}',
    notifications_empty:  '{{ t("matches.notifications_empty") }}',
    doug_toast:           '{{ t("matches.doug_toast") }}',
    research_error_toast: '{{ t("matches.research_error_toast") }}',
    time_just_now:        '{{ t("matches.time_just_now") }}',
    time_m_ago:           '{{ t("matches.time_m_ago") }}',
    time_h_ago:           '{{ t("matches.time_h_ago") }}',
    time_d_ago:           '{{ t("matches.time_d_ago") }}',
    failed_update:        '{{ t("matches.failed_update") }}',
    failed_rate:          '{{ t("matches.failed_rate") }}',
};
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// State
let allMatches = [];
let currentFilter = 'all';
let interactionCache = {}; // Cache interaction states by posting_id

// Load matches on page load
document.addEventListener('DOMContentLoaded', async () => {
    await loadMatches();
    await loadInteractions();
});

// Load interaction states for all matches
async function loadInteractions() {
    try {
        const postingIds = allMatches.map(m => m.posting_id);
        if (postingIds.length === 0) return;
        
        // Fetch interaction state for each posting
        const promises = postingIds.map(id => 
            fetch(`/api/interactions/state/${id}`).then(r => r.ok ? r.json() : null)
        );
        const results = await Promise.all(promises);
        
        // Build cache
        results.forEach(state => {
            if (state && state.posting_id) {
                interactionCache[state.posting_id] = state;
            }
        });
        
        // Merge into allMatches
        allMatches.forEach(m => {
            const state = interactionCache[m.posting_id];
            if (state) {
                m.is_read = state.is_read;
                m.is_favorited = state.is_favorited;
                m.is_interested = state.is_interested;
                m.match_feedback = state.match_feedback;
                m.journey_state = state.state;  // Track journey state for research button
            }
        });
        
        applyFilters();
    } catch (err) {
        console.error('Failed to load interactions:', err);
    }
}

// Filter tab clicks
document.querySelectorAll('.filter-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        applyFilters();
    });
});

async function loadMatches() {
    try {
        const res = await fetch('/api/matches/?limit=100');
        if (!res.ok) throw new Error('Failed to load matches');
        
        allMatches = await res.json();
        document.getElementById('loading-state').classList.add('hidden');
        
        if (allMatches.length === 0) {
            document.getElementById('empty-state').classList.remove('hidden');
        } else {
            applyFilters();
        }
    } catch (err) {
        console.error('Error loading matches:', err);
        document.getElementById('loading-state').innerHTML = 
            `<p style="color: var(--error)">${I18N.load_error}</p>`;
    }
}

function applyFilters() {
    const scoreMin = parseInt(document.getElementById('score-filter').value) || 0;
    const sortBy = document.getElementById('sort-by').value;
    
    let filtered = allMatches.filter(m => {
        // New journey filters
        if (currentFilter === 'favorites' && !m.is_favorited) return false;
        if (currentFilter === 'interested' && !m.is_interested) return false;
        if (currentFilter === 'unread' && m.is_read) return false;
        
        // Original recommendation filters
        if (currentFilter === 'APPLY' && m.recommendation !== 'APPLY') return false;
        if (currentFilter === 'SKIP' && m.recommendation !== 'SKIP') return false;
        
        // Score filter
        if (m.skill_match_score * 100 < scoreMin) return false;
        return true;
    });
    
    // Sort
    filtered.sort((a, b) => {
        if (sortBy === 'recommendation') {
            // APPLY first, then by score
            if (a.recommendation === 'APPLY' && b.recommendation !== 'APPLY') return -1;
            if (b.recommendation === 'APPLY' && a.recommendation !== 'APPLY') return 1;
            return b.skill_match_score - a.skill_match_score;
        } else if (sortBy === 'score') {
            return b.skill_match_score - a.skill_match_score;
        } else {
            return new Date(b.matched_at || 0) - new Date(a.matched_at || 0);
        }
    });
    
    renderMatches(filtered);
}

function renderMatches(matches) {
    const grid = document.getElementById('match-grid');
    
    if (matches.length === 0) {
        grid.innerHTML = `<p style="text-align:center; color:var(--text-muted); padding:2rem;">${I18N.no_results_filtered}</p>`;
        return;
    }
    
    grid.innerHTML = matches.map(m => renderMatchCard(m)).join('');
}

function renderMatchCard(m) {
    const score = Math.round(m.skill_match_score * 100);
    const scoreClass = score >= 80 ? 'high' : score >= 60 ? 'medium' : 'low';
    const cardClass = m.recommendation === 'APPLY' ? 'apply' : 'skip';
    const badgeClass = m.recommendation === 'APPLY' ? 'badge-apply' : 'badge-skip';
    
    const matchedDate = m.matched_at ? new Date(m.matched_at).toLocaleDateString() : '';
    
    // Thumbs state: -1 = üëé, 6 = üëç, 1-5 = stars, null = unrated
    const thumbsUp = m.user_rating === 6;
    const thumbsDown = m.user_rating === -1;
    const hasStars = m.user_rating >= 1 && m.user_rating <= 5;
    
    // Application status
    const isApplied = m.user_applied || m.application_status;
    const statusLabel = getStatusLabel(m.application_status, m.application_outcome);
    
    // Interaction state (from new API)
    const isFavorited = m.is_favorited || false;
    const isInterested = m.is_interested || false;
    const isRead = m.is_read || false;
    const matchFeedback = m.match_feedback || null;
    const unreadClass = !isRead ? 'unread' : '';
    
    return `
        <div class="match-card ${cardClass} ${unreadClass}" data-match-id="${m.match_id}" data-posting-id="${m.posting_id}">
            <!-- Favorite Button -->
            <button class="favorite-btn ${isFavorited ? 'active' : ''}" 
                    onclick="toggleFavorite(event, ${m.posting_id})" 
                    title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
                ${isFavorited ? '‚ù§Ô∏è' : 'ü§ç'}
            </button>
            
            <div>
                <span class="match-badge ${badgeClass}">
                    ${m.recommendation === 'APPLY' ? '‚úÖ Apply' : '‚ö†Ô∏è Review'}
                </span>
            </div>
            <div class="match-info">
                <h3 class="match-title">${escapeHtml(m.title)}</h3>
                <div class="match-company">${escapeHtml(m.company || I18N.company_unknown)}</div>
                <div class="match-meta">
                    <span class="match-score ${scoreClass}">${score}${I18N.match_score_suffix}</span>
                    ${m.location ? `<span>üìç ${escapeHtml(m.location)}</span>` : ''}
                    ${matchedDate ? `<span>üìÖ ${matchedDate}</span>` : ''}
                </div>
            </div>
            <div class="match-actions">
                <a href="/report/${m.match_id}" class="action-btn primary" onclick="markAsRead(${m.posting_id})">${I18N.view_report}</a>
                
                <!-- Interested Button -->
                <button class="interested-btn ${isInterested ? 'active' : ''}" 
                        onclick="toggleInterested(${m.posting_id})">
                    ${isInterested ? I18N.btn_interested : I18N.btn_interest}
                </button>
                
                <!-- Research Button (Doug) -->
                ${renderResearchButton(m)}
                
                <!-- Match Feedback (Agree/Disagree with match) -->
                <div class="match-feedback">
                    <button class="feedback-btn agree ${matchFeedback === 'agree' ? 'active' : ''}" 
                            onclick="sendFeedback(${m.posting_id}, 'agree')" title="Good match">
                        üëç Agree
                    </button>
                    <button class="feedback-btn disagree ${matchFeedback === 'disagree' ? 'active' : ''}" 
                            onclick="sendFeedback(${m.posting_id}, 'disagree')" title="Bad match">
                        üëé Disagree
                    </button>
                </div>
                
                <!-- Application Tracking -->
                <div class="application-tracker" id="app-tracker-${m.match_id}">
                    ${isApplied ? `
                        <select class="status-select" onchange="updateAppStatus(${m.match_id}, this.value)">
                            <option value="applied" ${m.application_status === 'applied' ? 'selected' : ''}>${I18N.status_applied}</option>
                            <option value="interviewing" ${m.application_status === 'interviewing' ? 'selected' : ''}>${I18N.status_interviewing}</option>
                            <option value="offered" ${m.application_status === 'offered' ? 'selected' : ''}>${I18N.status_offered}</option>
                            <option value="rejected" ${m.application_status === 'rejected' ? 'selected' : ''}>${I18N.status_rejected}</option>
                            <option value="withdrawn" ${m.application_status === 'withdrawn' ? 'selected' : ''}>${I18N.status_withdrawn}</option>
                        </select>
                        ${m.application_status === 'offered' || m.application_status === 'rejected' ? `
                            <select class="outcome-select" onchange="updateAppOutcome(${m.match_id}, this.value)">
                                <option value="">${I18N.outcome_placeholder}</option>
                                <option value="hired" ${m.application_outcome === 'hired' ? 'selected' : ''}>${I18N.outcome_hired}</option>
                                <option value="rejected" ${m.application_outcome === 'rejected' ? 'selected' : ''}>${I18N.outcome_not_selected}</option>
                                <option value="ghosted" ${m.application_outcome === 'ghosted' ? 'selected' : ''}>${I18N.outcome_ghosted}</option>
                                <option value="withdrew" ${m.application_outcome === 'withdrew' ? 'selected' : ''}>${I18N.outcome_withdrew}</option>
                            </select>
                        ` : ''}
                    ` : `
                        <button class="action-btn" onclick="markApplied(${m.match_id})">${I18N.btn_applied}</button>
                    `}
                </div>
                
                <!-- Thumbs Rating -->
                <div class="thumbs-row">
                    <button class="thumb-btn ${thumbsUp ? 'active good' : ''}" 
                            onclick="thumbsRate(${m.match_id}, 1)" title="Good match">üëç</button>
                    <button class="thumb-btn ${thumbsDown ? 'active bad' : ''}" 
                            onclick="thumbsRate(${m.match_id}, -1)" title="Bad match">üëé</button>
                </div>
                
                <!-- Star Rating (collapsible) -->
                <details class="star-details">
                    <summary>${I18N.rate_label}</summary>
                    <div class="rating-row">
                        ${[1,2,3,4,5].map(i => 
                            `<span class="rating-star ${hasStars && i <= m.user_rating ? 'active' : ''}" 
                                   data-rating="${i}" onclick="rateMatch(${m.match_id}, ${i})">${hasStars && i <= m.user_rating ? '‚òÖ' : '‚òÜ'}</span>`
                        ).join('')}
                    </div>
                </details>
            </div>
        </div>
    `;
}

function getStatusLabel(status, outcome) {
    if (outcome === 'hired') return 'üéâ Hired!';
    if (outcome === 'rejected') return '‚ùå Not selected';
    if (outcome === 'ghosted') return 'üëª Ghosted';
    if (outcome === 'withdrew') return '‚Ü©Ô∏è Withdrew';
    if (status === 'offered') return 'üéâ Offered!';
    if (status === 'interviewing') return 'üìû Interviewing';
    if (status === 'rejected') return '‚ùå Rejected';
    if (status === 'withdrawn') return '‚Ü©Ô∏è Withdrawn';
    if (status === 'applied') return '‚úì Applied';
    return '';
}

// === Journey Interaction Functions ===

async function toggleFavorite(event, postingId) {
    event.preventDefault();
    event.stopPropagation();
    
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    const newState = !match.is_favorited;
    
    try {
        const res = await fetch(`/api/interactions/favorite/${postingId}?favorited=${newState}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to update favorite');
        
        match.is_favorited = newState;
        applyFilters();
    } catch (err) {
        console.error('Failed to toggle favorite:', err);
    }
}

async function toggleInterested(postingId) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    const newState = !match.is_interested;
    
    try {
        const res = await fetch(`/api/interactions/interest/${postingId}?interested=${newState}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to update interest');
        
        match.is_interested = newState;
        applyFilters();
    } catch (err) {
        console.error('Failed to toggle interest:', err);
    }
}

async function sendFeedback(postingId, feedback) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    // Toggle off if same feedback clicked
    const newFeedback = match.match_feedback === feedback ? null : feedback;
    
    try {
        const url = newFeedback 
            ? `/api/interactions/feedback/${postingId}?feedback=${newFeedback}`
            : `/api/interactions/feedback/${postingId}`;
        
        const res = await fetch(url, { method: 'POST' });
        if (!res.ok) throw new Error('Failed to send feedback');
        
        match.match_feedback = newFeedback;
        applyFilters();
    } catch (err) {
        console.error('Failed to send feedback:', err);
    }
}

async function markAsRead(postingId) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match || match.is_read) return;
    
    try {
        await fetch(`/api/interactions/read/${postingId}`, {
            method: 'POST'
        });
        match.is_read = true;
    } catch (err) {
        console.error('Failed to mark as read:', err);
    }
}

// Research Button Rendering
function renderResearchButton(m) {
    const state = m.journey_state || 'unread';
    
    // Already researching
    if (state === 'researching') {
        return `<button class="research-btn pending" disabled>
            ${I18N.research_pending}
        </button>`;
    }
    
    // Research complete (informed)
    if (state === 'informed') {
        return `<button class="research-btn done" onclick="viewResearchReport(${m.posting_id})">
            ${I18N.research_view_doug}
        </button>`;
    }
    
    // Further along in journey (coaching, applied, etc.)
    if (['coaching', 'applied', 'outcome_pending', 'hired', 'rejected', 'ghosted'].includes(state)) {
        return `<button class="research-btn done" onclick="viewResearchReport(${m.posting_id})">
            ${I18N.research_view}
        </button>`;
    }
    
    // Not yet researched - show request button
    return `<button class="research-btn" onclick="requestResearch(${m.posting_id})">
        ${I18N.research_ask}
    </button>`;
}

// Request Doug to research
async function requestResearch(postingId) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    try {
        const res = await fetch(`/api/interactions/research/${postingId}`, {
            method: 'POST'
        });
        const data = await res.json();
        
        if (data.status === 'ok') {
            match.journey_state = 'researching';
            match.is_interested = true;
            applyFilters();
            
            // Show toast/notification
            showToast(I18N.doug_toast);
        } else if (data.status === 'already_processed') {
            showToast(`‚ÑπÔ∏è ${data.message}`);
        }
    } catch (err) {
        console.error('Failed to request research:', err);
        showToast(I18N.research_error_toast);
    }
}

// View research report (open messages for this posting)
function viewResearchReport(postingId) {
    // Navigate to messages filtered by this posting
    window.location.href = `/messages?posting=${postingId}`;
}

// Simple toast notification
function showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.add('show'), 10);
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// === End Journey Interaction Functions ===

async function viewReport(matchId) {
    const modal = document.getElementById('report-modal');
    const content = document.getElementById('report-content');
    const title = document.getElementById('report-title');
    
    content.innerHTML = `<div class="loading-state"><div class="spinner"></div><p>${I18N.report_loading}</p></div>`;
    modal.classList.remove('hidden');
    
    try {
        const res = await fetch(`/api/matches/${matchId}/report`);
        if (!res.ok) throw new Error('Failed to load report');
        
        const data = await res.json();
        title.textContent = 'Match Report';
        content.innerHTML = markdownToHtml(data.report);
        
        // Find posting to link to job
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            document.getElementById('view-job-btn').href = `/posting/${match.posting_id}`;
        }
    } catch (err) {
        content.innerHTML = `<p style="color: var(--error)">Failed to load report: ${err.message}</p>`;
    }
}

function closeReportModal() {
    document.getElementById('report-modal').classList.add('hidden');
}

async function markApplied(matchId) {
    try {
        const res = await fetch(`/api/matches/${matchId}/applied?applied=true`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to update');
        
        // Update local state and re-render
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.user_applied = true;
            match.application_status = 'applied';
        }
        applyFilters();
    } catch (err) {
        showToast(I18N.failed_update + err.message);
    }
}

async function updateAppStatus(matchId, status) {
    try {
        const res = await fetch(`/api/matches/${matchId}/application?status=${status}`, {
            method: 'PATCH'
        });
        if (!res.ok) throw new Error('Failed to update');
        
        // Update local state
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.application_status = status;
            match.user_applied = true;
        }
        applyFilters();
    } catch (err) {
        showToast(I18N.failed_update + err.message);
    }
}

async function updateAppOutcome(matchId, outcome) {
    if (!outcome) return;
    try {
        const res = await fetch(`/api/matches/${matchId}/application?outcome=${outcome}`, {
            method: 'PATCH'
        });
        if (!res.ok) throw new Error('Failed to update');
        
        // Update local state
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.application_outcome = outcome;
        }
        applyFilters();
    } catch (err) {
        showToast(I18N.failed_update + err.message);
    }
}

async function thumbsRate(matchId, thumbs) {
    try {
        const res = await fetch(`/api/matches/${matchId}/thumbs?thumbs=${thumbs}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to rate');
        
        // Update local state: -1 = bad, 6 = good
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.user_rating = thumbs === 1 ? 6 : -1;
        }
        applyFilters();
    } catch (err) {
        showToast(I18N.failed_rate + err.message);
    }
}

async function rateMatch(matchId, rating) {
    try {
        const res = await fetch(`/api/matches/${matchId}/rate?rating=${rating}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to rate');
        
        // Update local state
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.user_rating = rating;
        }
        applyFilters();
    } catch (err) {
        showToast(I18N.failed_rate + err.message);
    }
}

// Close modal on overlay click
document.getElementById('report-modal').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeReportModal();
});

// Close on Escape
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeReportModal();
});

// Utility: escape HTML
function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/[&<>"']/g, m => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    })[m]);
}

// Simple markdown to HTML (basic conversion)
function markdownToHtml(md) {
    return md
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/^\*\*(.+?)\*\*$/gm, '<p><strong>$1</strong></p>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/^\- (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
        .replace(/^---$/gm, '<hr>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^\|(.+)\|$/gm, (match, content) => {
            const cells = content.split('|').map(c => c.trim());
            return '<tr>' + cells.map(c => `<td>${c}</td>`).join('') + '</tr>';
        })
        .replace(/(<tr>.*<\/tr>)/gs, '<table>$1</table>')
        .replace(/\n/g, '<br>');
}

// === Notifications ===
loadNotifications();

async function loadNotifications() {
    try {
        // Get count
        const countRes = await fetch('/api/notifications/count');
        if (countRes.ok) {
            const count = await countRes.json();
            const badge = document.getElementById('notif-badge');
            if (badge && count.unread > 0) {
                badge.textContent = count.unread > 9 ? '9+' : count.unread;
                badge.classList.remove('hidden');
            } else if (badge) {
                badge.classList.add('hidden');
            }
        }
        
        // Get notifications
        const listRes = await fetch('/api/notifications/?limit=10');
        if (listRes.ok) {
            const notifications = await listRes.json();
            renderNotifications(notifications);
        }
    } catch (err) {
        console.error('Failed to load notifications:', err);
    }
}

function renderNotifications(notifications) {
    const list = document.getElementById('notif-list');
    if (!list) return;
    
    if (notifications.length === 0) {
        list.innerHTML = `<li class="notification-empty">${I18N.notifications_empty}</li>`;
        return;
    }
    
    list.innerHTML = notifications.map(n => `
        <li class="notification-item ${n.read_at ? '' : 'unread'}" 
            onclick="clickNotification(${n.notification_id}, '${escapeHtml(n.link || '')}')">
            <div class="notification-title">${escapeHtml(n.title)}</div>
            ${n.message ? `<div class="notification-message">${escapeHtml(n.message)}</div>` : ''}
            <div class="notification-time">${timeAgo(n.created_at)}</div>
        </li>
    `).join('');
}

function toggleNotifications(e) {
    e.stopPropagation();
    const dropdown = document.getElementById('notif-dropdown');
    if (dropdown) dropdown.classList.toggle('show');
}

async function clickNotification(id, link) {
    // Mark as read
    await fetch(`/api/notifications/${id}/read`, { method: 'POST' });
    loadNotifications();
    
    // Navigate if link
    if (link) {
        window.location.href = link;
    }
}

async function markAllRead(e) {
    e.stopPropagation();
    await fetch('/api/notifications/read-all', { method: 'POST' });
    loadNotifications();
}

function timeAgo(dateStr) {
    const date = new Date(dateStr);
    const now = new Date();
    const diff = Math.floor((now - date) / 1000);
    
    if (diff < 60) return I18N.time_just_now;
    if (diff < 3600) return Math.floor(diff / 60) + I18N.time_m_ago;
    if (diff < 86400) return Math.floor(diff / 3600) + I18N.time_h_ago;
    if (diff < 604800) return Math.floor(diff / 86400) + I18N.time_d_ago;
    return date.toLocaleDateString();
}

// Close dropdown on outside click
document.addEventListener('click', (e) => {
    if (!e.target.closest('.nav-notifications')) {
        const dd = document.getElementById('notif-dropdown');
        if (dd) dd.classList.remove('show');
    }
});
</script>
{% endblock %}
