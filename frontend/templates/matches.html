{% extends "base.html" %}

{% block title %}Match Dashboard ‚Äî talent.yoga{% endblock %}

{% block content %}
<nav class="navbar">
    <div class="nav-brand"><a href="/dashboard">üéØ talent.yoga</a></div>
    <div class="nav-links">
        <a href="/profile" class="nav-link">Profile</a>
        <a href="/matches" class="nav-link active">Matches</a>
    </div>
    <div class="nav-user">
        <div class="nav-notifications" onclick="toggleNotifications(event)">
            <span class="notification-bell">üîî</span>
            <span class="notification-badge hidden" id="notif-badge">0</span>
            <div class="notification-dropdown" id="notif-dropdown">
                <div class="notification-header">
                    <h4>Notifications</h4>
                    <button class="mark-all-read" onclick="markAllRead(event)">Mark all read</button>
                </div>
                <ul class="notification-list" id="notif-list">
                    <li class="notification-empty">No notifications</li>
                </ul>
            </div>
        </div>
        {% if user.avatar_url %}
        <img src="{{ user.avatar_url }}" alt="avatar" class="avatar">
        {% endif %}
        <span>{{ user.display_name or user.email }}</span>
        <a href="/auth/logout" class="logout-btn">Logout</a>
    </div>
</nav>

<main class="match-dashboard">
    <header class="dashboard-header">
        <h1>Your Matches</h1>
        <p class="subtitle">Jobs matched to your profile</p>
    </header>
    
    <!-- Filters -->
    <div class="filters">
        <div class="filter-tabs">
            <button class="filter-tab active" data-filter="all">All</button>
            <button class="filter-tab" data-filter="APPLY">‚úÖ Recommended</button>
            <button class="filter-tab" data-filter="SKIP">‚ö†Ô∏è Skipped</button>
            <button class="filter-tab" data-filter="favorites">‚ù§Ô∏è Favorites</button>
            <button class="filter-tab" data-filter="interested">‚úã Interested</button>
            <button class="filter-tab" data-filter="unread">üîµ Unread</button>
        </div>
        <div class="filter-controls">
            <select id="score-filter" onchange="applyFilters()">
                <option value="">Any score</option>
                <option value="90">90%+</option>
                <option value="80">80%+</option>
                <option value="70">70%+</option>
            </select>
            <select id="sort-by" onchange="applyFilters()">
                <option value="recommendation">Sort: Recommended first</option>
                <option value="score">Sort: Score</option>
                <option value="date">Sort: Newest</option>
            </select>
        </div>
    </div>
    
    <!-- Match Cards -->
    <div class="match-grid" id="match-grid">
        <!-- Populated by JS -->
    </div>
    
    <!-- Empty State -->
    <div class="empty-state hidden" id="empty-state">
        <span class="empty-icon">üéØ</span>
        <h2>No matches yet</h2>
        <p>Complete your <a href="/profile">profile</a> to start seeing job matches.</p>
    </div>
    
    <!-- Loading -->
    <div class="loading-state" id="loading-state">
        <div class="spinner"></div>
        <p>Loading matches...</p>
    </div>
</main>

<!-- Report Modal -->
<div class="modal-overlay hidden" id="report-modal">
    <div class="modal modal-large">
        <div class="modal-header">
            <h2 id="report-title">Match Report</h2>
            <button class="modal-close" onclick="closeReportModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="report-content" id="report-content">
                <!-- Rendered markdown -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeReportModal()">Close</button>
            <a href="#" target="_blank" class="btn" id="view-job-btn">View Original Job</a>
        </div>
    </div>
</div>

<style>
/* Match Dashboard Styles */
.match-dashboard {
    max-width: 1100px;
    margin: 0 auto;
    padding: 2rem;
}

.dashboard-header {
    margin-bottom: 1.5rem;
}

.dashboard-header h1 {
    margin-bottom: 0.25rem;
}

.subtitle {
    color: var(--text-muted);
}

/* Nav Links */
.nav-links {
    display: flex;
    gap: 1rem;
}

.nav-link {
    text-decoration: none;
    color: var(--text-muted);
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
}

.nav-link:hover, .nav-link.active {
    color: var(--text);
    background: var(--bg);
}

/* Filters */
.filters {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    gap: 1rem;
    flex-wrap: wrap;
}

.filter-tabs {
    display: flex;
    gap: 0.5rem;
}

.filter-tab {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    background: var(--card-bg);
    border-radius: 0.5rem;
    cursor: pointer;
    font-size: 0.875rem;
    transition: all 0.2s;
}

.filter-tab:hover {
    border-color: var(--primary);
}

.filter-tab.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.filter-controls {
    display: flex;
    gap: 0.75rem;
}

.filter-controls select {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    border-radius: 0.5rem;
    background: var(--card-bg);
    font-size: 0.875rem;
}

/* Match Grid */
.match-grid {
    display: grid;
    gap: 1rem;
}

/* Match Card */
.match-card {
    background: var(--card-bg);
    border-radius: 0.75rem;
    padding: 1.25rem;
    border: 1px solid var(--border);
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 1rem;
    align-items: start;
    transition: box-shadow 0.2s, border-color 0.2s;
}

.match-card:hover {
    box-shadow: 0 4px 12px rgb(0 0 0 / 0.1);
    border-color: var(--primary);
}

.match-card.apply {
    border-left: 4px solid var(--success);
}

.match-card.skip {
    border-left: 4px solid #f59e0b;
}

/* Badge */
.match-badge {
    padding: 0.375rem 0.75rem;
    border-radius: 1rem;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
}

.badge-apply {
    background: #dcfce7;
    color: #166534;
}

.badge-skip {
    background: #fef3c7;
    color: #92400e;
}

/* Match Info */
.match-info {
    min-width: 0;
}

.match-title {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
    color: var(--text);
}

.match-company {
    color: var(--text-muted);
    margin-bottom: 0.5rem;
}

.match-meta {
    display: flex;
    gap: 1rem;
    font-size: 0.875rem;
    color: var(--text-muted);
    flex-wrap: wrap;
}

.match-score {
    font-weight: 600;
}

.match-score.high { color: var(--success); }
.match-score.medium { color: #f59e0b; }
.match-score.low { color: var(--error); }

.match-highlight {
    margin-top: 0.75rem;
    padding: 0.5rem 0.75rem;
    background: var(--bg);
    border-radius: 0.375rem;
    font-size: 0.875rem;
}

.match-highlight.concern {
    background: #fef3c7;
    color: #92400e;
}

.match-highlight.positive {
    background: #dcfce7;
    color: #166534;
}

/* Match Actions */
.match-actions {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    min-width: 120px;
}

.action-btn {
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background: var(--card-bg);
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.2s;
    text-align: center;
}

.action-btn:hover {
    border-color: var(--primary);
    color: var(--primary);
}

.action-btn.primary {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.action-btn.primary:hover {
    background: var(--primary-dark);
}

.action-btn.applied {
    background: var(--success);
    color: white;
    border-color: var(--success);
}

/* Rating */
.rating-row {
    display: flex;
    gap: 0.25rem;
    justify-content: center;
}

.rating-star {
    cursor: pointer;
    font-size: 1.25rem;
    color: #d1d5db;
    transition: color 0.15s;
}

.rating-star:hover, .rating-star.active {
    color: #fbbf24;
}

/* Thumbs Rating */
.thumbs-row {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
}

.thumb-btn {
    padding: 0.375rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background: var(--card-bg);
    cursor: pointer;
    font-size: 1.25rem;
    transition: all 0.15s;
}

.thumb-btn:hover {
    border-color: var(--primary);
    transform: scale(1.1);
}

.thumb-btn.active.good {
    background: #dcfce7;
    border-color: #22c55e;
}

.thumb-btn.active.bad {
    background: #fee2e2;
    border-color: #ef4444;
}

/* Favorite Button */
.favorite-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #d1d5db;
    transition: all 0.2s;
    padding: 0.25rem;
    line-height: 1;
}

.favorite-btn:hover {
    transform: scale(1.2);
}

.favorite-btn.active {
    color: #ef4444;
}

/* Interested Button */
.interested-btn {
    background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s;
}

.interested-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
}

.interested-btn.active {
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
}

/* Research Button (Doug) */
.research-btn {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s;
}

.research-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
}

.research-btn.pending {
    background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    cursor: wait;
}

.research-btn.done {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
}

/* Toast Notifications */
.toast {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: var(--card-bg);
    color: var(--text);
    padding: 1rem 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border);
    z-index: 9999;
    opacity: 0;
    transition: all 0.3s ease;
}

.toast.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
}

/* Unread indicator */
.match-card.unread {
    border-left: 4px solid #3b82f6 !important;
}

.match-card.unread::before {
    content: '';
    position: absolute;
    top: 0.75rem;
    left: 0.75rem;
    width: 8px;
    height: 8px;
    background: #3b82f6;
    border-radius: 50%;
}

/* Match card needs relative positioning for absolute children */
.match-card {
    position: relative;
}

/* Match Feedback (Agree/Disagree) */
.match-feedback {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
    margin-top: 0.25rem;
}

.feedback-btn {
    padding: 0.25rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background: var(--card-bg);
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.15s;
}

.feedback-btn:hover {
    border-color: var(--primary);
}

.feedback-btn.agree.active {
    background: #dcfce7;
    border-color: #22c55e;
    color: #166534;
}

.feedback-btn.disagree.active {
    background: #fee2e2;
    border-color: #ef4444;
    color: #991b1b;
}

/* Star details */
.star-details {
    font-size: 0.75rem;
}

.star-details summary {
    cursor: pointer;
    color: var(--text-muted);
    text-align: center;
}

.star-details[open] summary {
    margin-bottom: 0.25rem;
}

/* Application Tracker */
.application-tracker {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
}

.status-select, .outcome-select {
    padding: 0.375rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background: var(--card-bg);
    font-size: 0.75rem;
    cursor: pointer;
}

.status-select:focus, .outcome-select:focus {
    border-color: var(--primary);
    outline: none;
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-muted);
}

.empty-icon {
    font-size: 4rem;
    display: block;
    margin-bottom: 1rem;
}

.empty-state h2 {
    color: var(--text);
    margin-bottom: 0.5rem;
}

.empty-state a {
    color: var(--primary);
}

/* Loading */
.loading-state {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-muted);
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.hidden {
    display: none !important;
}

/* Modal */
.modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    z-index: 1000;
}

.modal {
    background: var(--card-bg);
    border-radius: 0.75rem;
    width: 100%;
    max-width: 500px;
    max-height: 90vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.modal-large {
    max-width: 800px;
}

.modal-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    font-size: 1.125rem;
}

.modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--text-muted);
}

.modal-body {
    padding: 1.5rem;
    overflow-y: auto;
    flex: 1;
}

.modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid var(--border);
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
}

/* Report Content */
.report-content {
    line-height: 1.7;
}

.report-content h1 { font-size: 1.5rem; margin-bottom: 1rem; }
.report-content h2 { font-size: 1.25rem; margin: 1.5rem 0 0.75rem; }
.report-content h3 { font-size: 1rem; margin: 1rem 0 0.5rem; }
.report-content p { margin-bottom: 0.75rem; }
.report-content hr { margin: 1rem 0; border: none; border-top: 1px solid var(--border); }
.report-content ul { padding-left: 1.5rem; margin-bottom: 0.75rem; }
.report-content table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.875rem; }
.report-content th, .report-content td { padding: 0.5rem; border: 1px solid var(--border); text-align: left; }
.report-content th { background: var(--bg); }

.btn-secondary {
    background: var(--card-bg);
    color: var(--text);
    border: 1px solid var(--border);
}

.btn-secondary:hover {
    background: var(--bg);
}

/* Mobile */
@media (max-width: 768px) {
    .match-card {
        grid-template-columns: 1fr;
    }
    
    .match-actions {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .filters {
        flex-direction: column;
        align-items: stretch;
    }
    
    .filter-tabs {
        overflow-x: auto;
    }
    
    .filter-controls {
        flex-direction: column;
    }
    
    .navbar {
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    
    .nav-links {
        order: 3;
        width: 100%;
        justify-content: center;
    }
}
</style>

<script>
// State
let allMatches = [];
let currentFilter = 'all';
let interactionCache = {}; // Cache interaction states by posting_id

// Load matches on page load
document.addEventListener('DOMContentLoaded', async () => {
    await loadMatches();
    await loadInteractions();
});

// Load interaction states for all matches
async function loadInteractions() {
    try {
        const postingIds = allMatches.map(m => m.posting_id);
        if (postingIds.length === 0) return;
        
        // Fetch interaction state for each posting
        const promises = postingIds.map(id => 
            fetch(`/api/interactions/state/${id}`).then(r => r.ok ? r.json() : null)
        );
        const results = await Promise.all(promises);
        
        // Build cache
        results.forEach(state => {
            if (state && state.posting_id) {
                interactionCache[state.posting_id] = state;
            }
        });
        
        // Merge into allMatches
        allMatches.forEach(m => {
            const state = interactionCache[m.posting_id];
            if (state) {
                m.is_read = state.is_read;
                m.is_favorited = state.is_favorited;
                m.is_interested = state.is_interested;
                m.match_feedback = state.match_feedback;
                m.journey_state = state.state;  // Track journey state for research button
            }
        });
        
        applyFilters();
    } catch (err) {
        console.error('Failed to load interactions:', err);
    }
}

// Filter tab clicks
document.querySelectorAll('.filter-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        applyFilters();
    });
});

async function loadMatches() {
    try {
        const res = await fetch('/api/matches/?limit=100');
        if (!res.ok) throw new Error('Failed to load matches');
        
        allMatches = await res.json();
        document.getElementById('loading-state').classList.add('hidden');
        
        if (allMatches.length === 0) {
            document.getElementById('empty-state').classList.remove('hidden');
        } else {
            applyFilters();
        }
    } catch (err) {
        console.error('Error loading matches:', err);
        document.getElementById('loading-state').innerHTML = 
            '<p style="color: var(--error)">Failed to load matches. Please refresh.</p>';
    }
}

function applyFilters() {
    const scoreMin = parseInt(document.getElementById('score-filter').value) || 0;
    const sortBy = document.getElementById('sort-by').value;
    
    let filtered = allMatches.filter(m => {
        // New journey filters
        if (currentFilter === 'favorites' && !m.is_favorited) return false;
        if (currentFilter === 'interested' && !m.is_interested) return false;
        if (currentFilter === 'unread' && m.is_read) return false;
        
        // Original recommendation filters
        if (currentFilter === 'APPLY' && m.recommendation !== 'APPLY') return false;
        if (currentFilter === 'SKIP' && m.recommendation !== 'SKIP') return false;
        
        // Score filter
        if (m.skill_match_score * 100 < scoreMin) return false;
        return true;
    });
    
    // Sort
    filtered.sort((a, b) => {
        if (sortBy === 'recommendation') {
            // APPLY first, then by score
            if (a.recommendation === 'APPLY' && b.recommendation !== 'APPLY') return -1;
            if (b.recommendation === 'APPLY' && a.recommendation !== 'APPLY') return 1;
            return b.skill_match_score - a.skill_match_score;
        } else if (sortBy === 'score') {
            return b.skill_match_score - a.skill_match_score;
        } else {
            return new Date(b.matched_at || 0) - new Date(a.matched_at || 0);
        }
    });
    
    renderMatches(filtered);
}

function renderMatches(matches) {
    const grid = document.getElementById('match-grid');
    
    if (matches.length === 0) {
        grid.innerHTML = '<p style="text-align:center; color:var(--text-muted); padding:2rem;">No matches found with current filters.</p>';
        return;
    }
    
    grid.innerHTML = matches.map(m => renderMatchCard(m)).join('');
}

function renderMatchCard(m) {
    const score = Math.round(m.skill_match_score * 100);
    const scoreClass = score >= 80 ? 'high' : score >= 60 ? 'medium' : 'low';
    const cardClass = m.recommendation === 'APPLY' ? 'apply' : 'skip';
    const badgeClass = m.recommendation === 'APPLY' ? 'badge-apply' : 'badge-skip';
    
    const matchedDate = m.matched_at ? new Date(m.matched_at).toLocaleDateString() : '';
    
    // Thumbs state: -1 = üëé, 6 = üëç, 1-5 = stars, null = unrated
    const thumbsUp = m.user_rating === 6;
    const thumbsDown = m.user_rating === -1;
    const hasStars = m.user_rating >= 1 && m.user_rating <= 5;
    
    // Application status
    const isApplied = m.user_applied || m.application_status;
    const statusLabel = getStatusLabel(m.application_status, m.application_outcome);
    
    // Interaction state (from new API)
    const isFavorited = m.is_favorited || false;
    const isInterested = m.is_interested || false;
    const isRead = m.is_read || false;
    const matchFeedback = m.match_feedback || null;
    const unreadClass = !isRead ? 'unread' : '';
    
    return `
        <div class="match-card ${cardClass} ${unreadClass}" data-match-id="${m.match_id}" data-posting-id="${m.posting_id}">
            <!-- Favorite Button -->
            <button class="favorite-btn ${isFavorited ? 'active' : ''}" 
                    onclick="toggleFavorite(event, ${m.posting_id})" 
                    title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
                ${isFavorited ? '‚ù§Ô∏è' : 'ü§ç'}
            </button>
            
            <div>
                <span class="match-badge ${badgeClass}">
                    ${m.recommendation === 'APPLY' ? '‚úÖ Apply' : '‚ö†Ô∏è Review'}
                </span>
            </div>
            <div class="match-info">
                <h3 class="match-title">${escapeHtml(m.title)}</h3>
                <div class="match-company">${escapeHtml(m.company || 'Company not specified')}</div>
                <div class="match-meta">
                    <span class="match-score ${scoreClass}">${score}% match</span>
                    ${m.location ? `<span>üìç ${escapeHtml(m.location)}</span>` : ''}
                    ${matchedDate ? `<span>üìÖ ${matchedDate}</span>` : ''}
                </div>
            </div>
            <div class="match-actions">
                <a href="/report/${m.match_id}" class="action-btn primary" onclick="markAsRead(${m.posting_id})">View Report</a>
                
                <!-- Interested Button -->
                <button class="interested-btn ${isInterested ? 'active' : ''}" 
                        onclick="toggleInterested(${m.posting_id})">
                    ${isInterested ? '‚úÖ Interested' : '‚úã I\'m Interested'}
                </button>
                
                <!-- Research Button (Doug) -->
                ${renderResearchButton(m)}
                
                <!-- Match Feedback (Agree/Disagree with match) -->
                <div class="match-feedback">
                    <button class="feedback-btn agree ${matchFeedback === 'agree' ? 'active' : ''}" 
                            onclick="sendFeedback(${m.posting_id}, 'agree')" title="Good match">
                        üëç Agree
                    </button>
                    <button class="feedback-btn disagree ${matchFeedback === 'disagree' ? 'active' : ''}" 
                            onclick="sendFeedback(${m.posting_id}, 'disagree')" title="Bad match">
                        üëé Disagree
                    </button>
                </div>
                
                <!-- Application Tracking -->
                <div class="application-tracker" id="app-tracker-${m.match_id}">
                    ${isApplied ? `
                        <select class="status-select" onchange="updateAppStatus(${m.match_id}, this.value)">
                            <option value="applied" ${m.application_status === 'applied' ? 'selected' : ''}>‚úì Applied</option>
                            <option value="interviewing" ${m.application_status === 'interviewing' ? 'selected' : ''}>üìû Interviewing</option>
                            <option value="offered" ${m.application_status === 'offered' ? 'selected' : ''}>üéâ Offered!</option>
                            <option value="rejected" ${m.application_status === 'rejected' ? 'selected' : ''}>‚ùå Rejected</option>
                            <option value="withdrawn" ${m.application_status === 'withdrawn' ? 'selected' : ''}>‚Ü©Ô∏è Withdrawn</option>
                        </select>
                        ${m.application_status === 'offered' || m.application_status === 'rejected' ? `
                            <select class="outcome-select" onchange="updateAppOutcome(${m.match_id}, this.value)">
                                <option value="">Outcome...</option>
                                <option value="hired" ${m.application_outcome === 'hired' ? 'selected' : ''}>üéâ Hired!</option>
                                <option value="rejected" ${m.application_outcome === 'rejected' ? 'selected' : ''}>Not selected</option>
                                <option value="ghosted" ${m.application_outcome === 'ghosted' ? 'selected' : ''}>üëª Ghosted</option>
                                <option value="withdrew" ${m.application_outcome === 'withdrew' ? 'selected' : ''}>Withdrew</option>
                            </select>
                        ` : ''}
                    ` : `
                        <button class="action-btn" onclick="markApplied(${m.match_id})">I Applied</button>
                    `}
                </div>
                
                <!-- Thumbs Rating -->
                <div class="thumbs-row">
                    <button class="thumb-btn ${thumbsUp ? 'active good' : ''}" 
                            onclick="thumbsRate(${m.match_id}, 1)" title="Good match">üëç</button>
                    <button class="thumb-btn ${thumbsDown ? 'active bad' : ''}" 
                            onclick="thumbsRate(${m.match_id}, -1)" title="Bad match">üëé</button>
                </div>
                
                <!-- Star Rating (collapsible) -->
                <details class="star-details">
                    <summary>Rate (1-5)</summary>
                    <div class="rating-row">
                        ${[1,2,3,4,5].map(i => 
                            `<span class="rating-star ${hasStars && i <= m.user_rating ? 'active' : ''}" 
                                   data-rating="${i}" onclick="rateMatch(${m.match_id}, ${i})">${hasStars && i <= m.user_rating ? '‚òÖ' : '‚òÜ'}</span>`
                        ).join('')}
                    </div>
                </details>
            </div>
        </div>
    `;
}

function getStatusLabel(status, outcome) {
    if (outcome === 'hired') return 'üéâ Hired!';
    if (outcome === 'rejected') return '‚ùå Not selected';
    if (outcome === 'ghosted') return 'üëª Ghosted';
    if (outcome === 'withdrew') return '‚Ü©Ô∏è Withdrew';
    if (status === 'offered') return 'üéâ Offered!';
    if (status === 'interviewing') return 'üìû Interviewing';
    if (status === 'rejected') return '‚ùå Rejected';
    if (status === 'withdrawn') return '‚Ü©Ô∏è Withdrawn';
    if (status === 'applied') return '‚úì Applied';
    return '';
}

// === Journey Interaction Functions ===

async function toggleFavorite(event, postingId) {
    event.preventDefault();
    event.stopPropagation();
    
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    const newState = !match.is_favorited;
    
    try {
        const res = await fetch(`/api/interactions/favorite/${postingId}?favorited=${newState}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to update favorite');
        
        match.is_favorited = newState;
        applyFilters();
    } catch (err) {
        console.error('Failed to toggle favorite:', err);
    }
}

async function toggleInterested(postingId) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    const newState = !match.is_interested;
    
    try {
        const res = await fetch(`/api/interactions/interest/${postingId}?interested=${newState}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to update interest');
        
        match.is_interested = newState;
        applyFilters();
    } catch (err) {
        console.error('Failed to toggle interest:', err);
    }
}

async function sendFeedback(postingId, feedback) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    // Toggle off if same feedback clicked
    const newFeedback = match.match_feedback === feedback ? null : feedback;
    
    try {
        const url = newFeedback 
            ? `/api/interactions/feedback/${postingId}?feedback=${newFeedback}`
            : `/api/interactions/feedback/${postingId}`;
        
        const res = await fetch(url, { method: 'POST' });
        if (!res.ok) throw new Error('Failed to send feedback');
        
        match.match_feedback = newFeedback;
        applyFilters();
    } catch (err) {
        console.error('Failed to send feedback:', err);
    }
}

async function markAsRead(postingId) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match || match.is_read) return;
    
    try {
        await fetch(`/api/interactions/read/${postingId}`, {
            method: 'POST'
        });
        match.is_read = true;
    } catch (err) {
        console.error('Failed to mark as read:', err);
    }
}

// Research Button Rendering
function renderResearchButton(m) {
    const state = m.journey_state || 'unread';
    
    // Already researching
    if (state === 'researching') {
        return `<button class="research-btn pending" disabled>
            üîç Doug is researching...
        </button>`;
    }
    
    // Research complete (informed)
    if (state === 'informed') {
        return `<button class="research-btn done" onclick="viewResearchReport(${m.posting_id})">
            üìã View Doug's Report
        </button>`;
    }
    
    // Further along in journey (coaching, applied, etc.)
    if (['coaching', 'applied', 'outcome_pending', 'hired', 'rejected', 'ghosted'].includes(state)) {
        return `<button class="research-btn done" onclick="viewResearchReport(${m.posting_id})">
            üìã View Research
        </button>`;
    }
    
    // Not yet researched - show request button
    return `<button class="research-btn" onclick="requestResearch(${m.posting_id})">
        üîç Ask Doug to Research
    </button>`;
}

// Request Doug to research
async function requestResearch(postingId) {
    const match = allMatches.find(m => m.posting_id === postingId);
    if (!match) return;
    
    try {
        const res = await fetch(`/api/interactions/research/${postingId}`, {
            method: 'POST'
        });
        const data = await res.json();
        
        if (data.status === 'ok') {
            match.journey_state = 'researching';
            match.is_interested = true;
            applyFilters();
            
            // Show toast/notification
            showToast("üîç Doug is on it! You'll get a message when ready.");
        } else if (data.status === 'already_processed') {
            showToast(`‚ÑπÔ∏è ${data.message}`);
        }
    } catch (err) {
        console.error('Failed to request research:', err);
        showToast('‚ùå Failed to request research');
    }
}

// View research report (open messages for this posting)
function viewResearchReport(postingId) {
    // Navigate to messages filtered by this posting
    window.location.href = `/messages?posting=${postingId}`;
}

// Simple toast notification
function showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.add('show'), 10);
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// === End Journey Interaction Functions ===

async function viewReport(matchId) {
    const modal = document.getElementById('report-modal');
    const content = document.getElementById('report-content');
    const title = document.getElementById('report-title');
    
    content.innerHTML = '<div class="loading-state"><div class="spinner"></div><p>Loading report...</p></div>';
    modal.classList.remove('hidden');
    
    try {
        const res = await fetch(`/api/matches/${matchId}/report`);
        if (!res.ok) throw new Error('Failed to load report');
        
        const data = await res.json();
        title.textContent = 'Match Report';
        content.innerHTML = markdownToHtml(data.report);
        
        // Find posting to link to job
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            document.getElementById('view-job-btn').href = `/posting/${match.posting_id}`;
        }
    } catch (err) {
        content.innerHTML = `<p style="color: var(--error)">Failed to load report: ${err.message}</p>`;
    }
}

function closeReportModal() {
    document.getElementById('report-modal').classList.add('hidden');
}

async function markApplied(matchId) {
    try {
        const res = await fetch(`/api/matches/${matchId}/applied?applied=true`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to update');
        
        // Update local state and re-render
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.user_applied = true;
            match.application_status = 'applied';
        }
        applyFilters();
    } catch (err) {
        alert('Failed to update: ' + err.message);
    }
}

async function updateAppStatus(matchId, status) {
    try {
        const res = await fetch(`/api/matches/${matchId}/application?status=${status}`, {
            method: 'PATCH'
        });
        if (!res.ok) throw new Error('Failed to update');
        
        // Update local state
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.application_status = status;
            match.user_applied = true;
        }
        applyFilters();
    } catch (err) {
        alert('Failed to update: ' + err.message);
    }
}

async function updateAppOutcome(matchId, outcome) {
    if (!outcome) return;
    try {
        const res = await fetch(`/api/matches/${matchId}/application?outcome=${outcome}`, {
            method: 'PATCH'
        });
        if (!res.ok) throw new Error('Failed to update');
        
        // Update local state
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.application_outcome = outcome;
        }
        applyFilters();
    } catch (err) {
        alert('Failed to update: ' + err.message);
    }
}

async function thumbsRate(matchId, thumbs) {
    try {
        const res = await fetch(`/api/matches/${matchId}/thumbs?thumbs=${thumbs}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to rate');
        
        // Update local state: -1 = bad, 6 = good
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.user_rating = thumbs === 1 ? 6 : -1;
        }
        applyFilters();
    } catch (err) {
        alert('Failed to rate: ' + err.message);
    }
}

async function rateMatch(matchId, rating) {
    try {
        const res = await fetch(`/api/matches/${matchId}/rate?rating=${rating}`, {
            method: 'POST'
        });
        if (!res.ok) throw new Error('Failed to rate');
        
        // Update local state
        const match = allMatches.find(m => m.match_id === matchId);
        if (match) {
            match.user_rating = rating;
        }
        applyFilters();
    } catch (err) {
        alert('Failed to rate: ' + err.message);
    }
}

// Close modal on overlay click
document.getElementById('report-modal').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeReportModal();
});

// Close on Escape
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeReportModal();
});

// Utility: escape HTML
function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/[&<>"']/g, m => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    })[m]);
}

// Simple markdown to HTML (basic conversion)
function markdownToHtml(md) {
    return md
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/^\*\*(.+?)\*\*$/gm, '<p><strong>$1</strong></p>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/^\- (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
        .replace(/^---$/gm, '<hr>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^\|(.+)\|$/gm, (match, content) => {
            const cells = content.split('|').map(c => c.trim());
            return '<tr>' + cells.map(c => `<td>${c}</td>`).join('') + '</tr>';
        })
        .replace(/(<tr>.*<\/tr>)/gs, '<table>$1</table>')
        .replace(/\n/g, '<br>');
}

// === Notifications ===
loadNotifications();

async function loadNotifications() {
    try {
        // Get count
        const countRes = await fetch('/api/notifications/count');
        if (countRes.ok) {
            const count = await countRes.json();
            const badge = document.getElementById('notif-badge');
            if (count.unread > 0) {
                badge.textContent = count.unread > 9 ? '9+' : count.unread;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }
        
        // Get notifications
        const listRes = await fetch('/api/notifications/?limit=10');
        if (listRes.ok) {
            const notifications = await listRes.json();
            renderNotifications(notifications);
        }
    } catch (err) {
        console.error('Failed to load notifications:', err);
    }
}

function renderNotifications(notifications) {
    const list = document.getElementById('notif-list');
    
    if (notifications.length === 0) {
        list.innerHTML = '<li class="notification-empty">No notifications</li>';
        return;
    }
    
    list.innerHTML = notifications.map(n => `
        <li class="notification-item ${n.read_at ? '' : 'unread'}" 
            onclick="clickNotification(${n.notification_id}, '${n.link || ''}')">
            <div class="notification-title">${escapeHtml(n.title)}</div>
            ${n.message ? `<div class="notification-message">${escapeHtml(n.message)}</div>` : ''}
            <div class="notification-time">${timeAgo(n.created_at)}</div>
        </li>
    `).join('');
}

function toggleNotifications(e) {
    e.stopPropagation();
    const dropdown = document.getElementById('notif-dropdown');
    dropdown.classList.toggle('show');
}

async function clickNotification(id, link) {
    // Mark as read
    await fetch(`/api/notifications/${id}/read`, { method: 'POST' });
    loadNotifications();
    
    // Navigate if link
    if (link) {
        window.location.href = link;
    }
}

async function markAllRead(e) {
    e.stopPropagation();
    await fetch('/api/notifications/read-all', { method: 'POST' });
    loadNotifications();
}

function timeAgo(dateStr) {
    const date = new Date(dateStr);
    const now = new Date();
    const diff = Math.floor((now - date) / 1000);
    
    if (diff < 60) return 'Just now';
    if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
    if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
    if (diff < 604800) return Math.floor(diff / 86400) + 'd ago';
    return date.toLocaleDateString();
}

// Close dropdown on outside click
document.addEventListener('click', (e) => {
    if (!e.target.closest('.nav-notifications')) {
        document.getElementById('notif-dropdown').classList.remove('show');
    }
});
</script>
{% endblock %}
